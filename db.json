[{"title":"【Intellij Idea 插件从入门到深坑】基础的AnAction","url":"%2Fpost%2F1f02658.html","content":"##  **简介**\n\n本篇博客主要是介绍 ` Intellij Idea `\n插件的基础环境的搭建，以及简单的入门操作，用于熟悉插件的编写流程，更快的熟悉和适应插件的编写。如有错误，请在留言中指正，谢谢。 [ 系列汇总地址\n](http://blog.csdn.net/guohaiyang1992/article/details/78838307)\n\n* * *\n\n##  **基础知识**\n\n###  **环境搭建**\n\n首先为了方便开发，我们采用 ` Intellij Idea ` 作为我们开发的IDE, [ 可以点此下载\n](https://www.jetbrains.com/idea/download) 。  \n安装过程比较简单我就不在此赘述了，下面我们讲解下如何设置，让你能够搭建好可以运行的插件系统。\n\n打开 ` Intellij Idea ` ，然后选择新建项目，然后按照下图操作：\n\n![设置项目\n](http://ozbc8g1sr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-12-18%20%E4%B8%8B%E5%8D%8811.58.59.png)\n\n然后选择Next ，然后输入你的项目名称，然后选择Finish，最后你的项目结构将如下图所示：\n\n![项目结构\n](http://ozbc8g1sr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-12-19%20%E4%B8%8A%E5%8D%8812.08.24.png)\n\n我们根据当前的图来简介下 ` Intellij Idea ` 插件开发项目的目录结构。\n\n  * ` src ` 目录，用于存储我们编写插件的源码 \n\n  * ` resources ` 目录， 用于存储我们所需的资源文件。其中比较重要的是在 ` META-INF ` 文件下的 ` plugin.xml ` ，它是插件的配置文件，用于配置插件的各种属性各种依赖，以及注册后续将接触到的 ` Action ` 、 ` Inspection ` 等，所以此文件很重要！！! \n\n通过上面的几个简单的步骤就可以搭建完成我们的开发环境了，下面我们编写个简单的例子来熟悉下如何进行插件的开发。\n\n* * *\n\n##  **入门操作**\n\n###  **action 是什么？**\n\n如果我上来就开始写代码你可能处于懵逼状态，好，我们先讲解下定义。  \n定义：用于描述一个动作、行为，可以通过快捷键、点选的方式进行触发。\n\n下面我们将讲解两种方式去创建 ` Action ` ：\n\n* * *\n\n###  **借助IDE创建Action**\n\n按照如下步骤进行操作：\n\n  1. 在Src目录下创建你的包，用于存储代码 \n  2. 选择你创建的包然后点击右键- >New \n  3. 然后选择最下方的Plugin Devkit->Action \n\n参考下图：\n\n![项目结构\n](http://ozbc8g1sr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-12-19%20%E4%B8%8A%E5%8D%8812.29.13.png)\n\n然后需要设置Action的各个属性，可以参考下图：\n\n![项目结构\n](http://ozbc8g1sr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-12-19%20%E4%B8%8B%E5%8D%8811.16.32.png)\n\n然后点击下一步，你就会发现你的对应包下面就有你设置好的Action的类了。你是否好奇IDE究竟为我们做了什么？还记得说过的比较重要的那个配置文件吗？打开看看吧，你的设置是不是都在里面？是不是恍然大悟了！\n\n下面介绍的创建 ` Action ` 的方法就是依照此原理进行的。\n\n* * *\n\n###  **手动创建Action**\n\n按照如下步骤进行操作：\n\n  1. 在Src目录下创建你的包，用于存储代码 \n  2. 选择你创建的包然后点击右键- >New \n  3. 然后选择Java Class,设置好你的Action名称点击完成 \n\n将你的类继承 ` AnAction ` ，然后重写 ` actionPerformed() ` 方法，如下图所示：\n\n![项目结构\n](http://ozbc8g1sr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-12-19%20%E4%B8%8B%E5%8D%8811.22.28.png)\n\n我们还要配置一下 ` plugin.xml ` ，将你的 ` Action ` 注册进去。  \n配置内容，如下图：\n\n![项目结构\n](http://ozbc8g1sr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-12-19%20%E4%B8%8B%E5%8D%8811.24.23.png)\n\n配置的内容参数的含义可以参考IDE生成 ` Action ` 时的讲解，都是对应的。\n\n* * *\n\n###  **讲解Action**\n\n这个类中比较重要的有两个方法：\n\n  * ` actionPerformed(AnActionEvent e) ` : 当用户点击IDE中对应Action的图标时会触发此方法，也就是说每选中一次触发一次。 \n  * ` update(AnActionEvent e) ` ：当IDE中需要展示你的Action图标的时候就会触发一次，当点击时也会触发且在 ` actionPerformed(AnActionEvent e) ` 之前触发。 \n\n* * *\n\n###  **实现个小功能**\n\n通过上面的介绍我们对 ` Action ` 大致有了一些了解，下面我们来实现一些功能，来更好的学习印证一下。\n\n这个例子应该是很普遍了，这个应该是官网的例子，就以此讲解吧，具体实现就是当点击你对应的 ` Action ` 的时候，弹出一个弹窗，下面我们看下如何实现。\n\n其实代码很简单，我们刚讲解了 ` Action ` 比较重要的就那两个方法，根据需求我们知道 ` actionPerformed(AnActionEvent\ne) ` 就可以满足效果，下面我们来编写代码。\n\n    \n``` \n      @Override\n        public void actionPerformed(AnActionEvent e) {\n            Messages.showMessageDialog(\"这个是我的测试弹窗！\", \"TestTile\", Messages.getWarningIcon());\n        }\n```\n\n可以看到代码确实很简单，然后我们点击运行即可， ` IDE ` 会自动打开新的 ` IDE ` 进程，如果没有直接打开对应的 ` IDE `\n，你需要手动选择打开的 ` Project ` 即可。需要注意的是， ` Intellij Idea ` 中使用的 ` Ui ` 相关的都是基于 `\njava ` 的，所以如果想高度定制，需要一些 ` java ui ` 的基础。\n\n好，我们验证下学习成果，点击自动打开的 ` IDE ` ，上方选择 ` help ` ，查看最下方是不是有你命名的 ` action `\n的名字，然后点击，是否出现弹窗，出现则成功。\n\n如果在 ` help ` 下没看到你的 ` action ` 名字，请按照如下修改 ` plugin.xml ` 中的对应代码：\n\n    \n```\n     <add-to-group group-id=\"HelpMenu\" anchor=\"last\"/>\n```\n\n然后，重新运行即可~\n\n此时重新进行点击查看应该就可以看到对应的效果了。\n\n注意：如果有其他情况还请下方留言。\n\n* * *\n\n##  总结\n\n至此已经基本了解了 ` Intellij Idea ` 的插件开发，是不是感觉还比较简单？后续会有更多更复杂的内容，敬请期待~\n\n学完了内容后，多回顾多思考，继续 [ 后续内容\n](http://blog.csdn.net/guohaiyang1992/article/details/78838307) 。\n\n","tags":["plugin"],"categories":["Intellij"]},{"title":"【Intellij Idea 插件】系列目录","url":"%2Fpost%2Fd4acd4c8.html","content":"#  **Intellij Idea 插件**\n\n* * *\n\n【Intellij Idea 插件从入门到深坑】让你能够熟悉Intellij Idea插件的开发，能够利用自己的所学，做出自己想要的东西。\n\n由于Intellij Idea 插件\n相关的资料比较匮乏，无论是从谷歌还是百度搜索，可用的资料都很少，但本系列还是结合网上教程和源码提炼出用法。当然难免会出现错误，还请留言指正，感谢。\n\n###  **目录**\n\n  * [ 基础的AnAction ](http://blog.csdn.net/guohaiyang1992/article/details/78848810)\n\n* * *\n\n###  **补充教程**\n\n","tags":["plugin"],"categories":["Intellij"]},{"title":"全屏到任意宽高的Dialog的写法","url":"%2Fpost%2F89cc6397.html","content":"##  **简介**\n\n本篇博客主要是介绍如何实现全屏 ` Dialog ` ,以及部分原理，具体细节可以参考对应 ` Dialog ` 的源码实现。\n\n* * *\n\n##  **基础知识**\n\n###  **前提**\n\n讲解前你需要具备如何去写一个 ` Dialog ` 的基础知识，因为本篇博客不会很细节的讲解此处内容，此博客会着重讲解如何实现一个全屏的 ` Dialog\n` ，当然有关此篇博客中探讨出现的问题或者其他的疑问欢迎留言提问 ~。\n\n* * *\n\n## **简介**\n本篇博客主要是介绍如何实现全屏`Dialog`,以及部分原理，具体细节可以参考对应`Dialog`的源码实现。\n\n---\n## **基础知识**\n### **前提**\n讲解前你需要具备如何去写一个`Dialog`的基础知识，因为本篇博客不会很细节的讲解此处内容，此博客会着重讲解如何实现一个全屏的`Dialog`，当然有关此篇博客中探讨出现的问题或者其他的疑问欢迎留言提问 ~。\n\n\n---\n## **实现方式**\n### **通过设置Style实现Dialog全屏**\n此方法比较简单的就可以实现全屏的`Dialog`，我们看下如何实现呢。\n\n首先需要在res/values/styles.xml内写入如下代码即可：\n\n```\n <!--此处的名字可以任意写，只要使用的时候匹配到即可-->\n <style name=\"dialog_style_1\">\n     <!--注意此处的属性，设置此属性后即可实现Dilaog全屏-->\n        <item name=\"android:windowFullscreen\">true</item>\n    </style>\n```\n\n是不是很简单，如上方声明好一个`Style`后，怎么使用呢？\n\n```\n// 方式1，直接继承Dialog的时候传入Style即可\npublic class Dialog1 extends Dialog {\n    public Dialog1(@NonNull Context context) {\n      //注意此处\n        super(context, R.style.dialog_style_1);\n        setContentView(R.layout.dialog_test_layout);\n    }\n}\n\n//------------------\n//方式2\nDialog dialog=new Dialog(context,R.style.dialog_style_1);\n```\n上面两种实现的效果一致，是不是很简单呢？\n\n来个效果图瞅瞅效果吧，效果图如下:\n<img src=\"http://ozbc8g1sr.bkt.clouddn.com/Screenshot_1510504940.png\" width=\"30%\" height=\"30%\" alt=\"通过Theme设置全屏Dialog \"/>\n\n总结：此类使用`theme` 的方式去设置全屏，设置`windowFullscreen`属性为true 即可\n\n - 优点：简单，全屏\n - 缺点：会导致整个屏幕被遮盖，包括状态栏，且点击状态栏会导致状态栏再次显示（体验并不好），只适合全屏。\n \n\n---\n### **通过设置Style实现Dialog全屏2**\n看到上面的标题，你是不是怀疑我写错了，并没有，这个也是通过Style实现的不过设置的属性和上面的不同，达到的效果也不尽相同。\n\n当然设置Style的方式和上面一样只需要换个属性就好了，按照如下设置：\n\n```\n<!--此属性设置的dialog可以依照布局的宽高去设定而不是wrap_content-->\n    <style name=\"dialog_style_2\">\n      <!--注意此处-->\n        <item name=\"android:windowIsFloating\">false</item>\n    </style>\n```\n当然使用方式也是一致的，按照如之前的使用方式，只需将`R.style.dialog_style_1`更改为`R.style.dialog_style_2` 即可。\n\n看下效果图：\n<img src=\"http://ozbc8g1sr.bkt.clouddn.com/device-2017-11-13-010314.png\" width=\"30%\" height=\"30%\" alt=\"通过Theme设置全屏Dialog \"/>\n\n总结：此方法通过设置`theme` 的`windowIsFloating` 为false ，从而使得`contentView` 的`match_parent` 对`window`起作用，从而达到全屏的效果，否则会设置window的宽高为`wrap_content`，无法全屏,当然你可以通过设置一个空的Style,也可达到相同效果（`windowIsFloating` 默认为false），但不可以不设置Style，因为会有默认的Style。\n\n - 优点：简单，显示的window在状态栏下面\n - 缺点：粒度小，且window一直为match_parent 即使内容变小，window仍不变小 ，导致外部无法触发点击消失事件，适合显示在状态栏下全屏的dialog，只适合全屏\n\n---\n### **通过代码设置Dilaog全屏或者任意宽高**\n这个方法内就比较灵活了，你可以任意设置Dilaog的宽高，不过代码量也会变高，好吧，看下怎么实现。\n上代码：\n\n```\npublic class Dialog3 extends Dialog {\n\n\n    public Dialog3(@NonNull Context context, float widthPercent, float heightPercent) {\n        super(context);\n        setContentView(R.layout.dialog_test_layout);\n        // 注意此方法一定要在setContentView后面，否则设置内容会被setContentView覆盖，此时由于默认没使用theme,按照默认的背景图来设置\n        // 此时再设置window的宽高进行更细致的修改window参数\n        initWidthAndHeightByPercent(widthPercent, heightPercent);\n    }\n\n    /**\n     * 用于根据传入的宽高的比例显示window\n     */\n    private void initWidthAndHeightByPercent(float widthPercent, float heightPercent) {\n        WindowManager windowManager = getWindow().getWindowManager();\n        Display display = windowManager.getDefaultDisplay();\n        WindowManager.LayoutParams lp = getWindow().getAttributes();\n        //decorView是window中的最顶层view，可以从window中获取到decorView,获取状态栏的高度\n        int statusBarHeight = getStatusBarHeight();\n        lp.width = (int) (display.getWidth() * widthPercent); //设置宽度\n        //高度值需要减去状态栏的高度\n        lp.height = (int) ((display.getHeight() - statusBarHeight) * heightPercent);\n        getWindow().setAttributes(lp);\n        // 注意此处必须设置,因为window默认会设置一个有padding 的背景\n        getWindow().setBackgroundDrawable(new ColorDrawable(Color.WHITE));\n    }\n\n    private int getStatusBarHeight() {\n        int statusBarHeight1 = -1;\n        //获取status_bar_height资源的ID\n        int resourceId = getContext().getResources().getIdentifier(\"status_bar_height\", \"dimen\", \"android\");\n        if (resourceId > 0) {\n            //根据资源ID获取响应的尺寸值\n            statusBarHeight1 = getContext().getResources().getDimensionPixelSize(resourceId);\n        }\n        return statusBarHeight1;\n    }\n}\n```\n不要被上面的代码吓坏了，其实内容也不多，我来讲解下主要过程，首先需要注意的就是你设置`window`的宽高的代码一定要在`setContentView`之后，原因和方法2中提到的相关，其内部会将不设置`android:windowIsFloating` 属性的`window`按照`wrap_content`来测量，所以，即使你设置`match_parent`也是无效的，而我们如果通过代码手动修改宽高当然也就达到修改的目的，如果顺序修改，就会导致`setContentView`方法将其重置。\n\n具体参考`PhoneWindow`的代码(节选)：\n\n```\n if (mIsFloating) {\n     setLayout(WRAP_CONTENT, WRAP_CONTENT);\n     setFlags(0, flagsToUpdate);\n        } \n```\n\n这个代码就是在`setContentView`内执行，很明显，由于你没设置`Style`，系统将会使用默认的`Style`从而导致`mIsFloating` 为`true`,然后通过代码再次修改`window`的宽高即可达到修改的结果。\n\n从上面那个比较长的代码我们也可以看出，`Dialog`的宽高是可以自己设定的，所以通过此方法可以设定`Dialog`的任意宽高。\n\n效果同效果图2，在此不重复截图了。\n\n总结：  使用代码设置宽高\n \n\n - 优点：粒度小，可以任意设置\n \n -  缺点：操作略微复杂\n\n\n\n\n---\n##总结\n至此你已经掌握了三种设置`Dilaog`全屏的方式和一种设置`Dilaog`任意宽高的方式，也知道了他们每个的优缺点，我将代码上传至 -> [CSDN](http://download.csdn.net/download/guohaiyang1992/10115667) <- 中，写了个简单的工具，后续加入动画的话，可以实现各种大小各种位置的Dialog的显示，如有疑问，欢迎留言。","tags":["源码"],"categories":["那些坑"]},{"title":"github 项目推荐之个人版","url":"%2Fpost%2F98b3971c.html","content":"###  简介：\n\n####  此博文主要介绍一下我个人写的一些开源的库和框架，为的是知识的交流沟通、互相学习。\n\n* * *\n\n###  项目列表：\n\n  * [ ThreadAnnotation（注解实现线程切换和方法执行时间监听） ](https://github.com/guohaiyang1992/ThreadAnnotation)\n\n  * [ ThreadUtils（链式切换线程，可设置延时） ](https://github.com/guohaiyang1992/ThreadUtils)\n\n  * [ UiWatchDog（Ui监视工具，精确定位问题代码） ](https://github.com/guohaiyang1992/UiWatchDog)\n\n  * [ PermissionHelper（权限申请工具，苦口婆心式的引导+简单高效的使用） ](https://github.com/guohaiyang1992/PermissionHelper)\n\n  * [ StatusBarControl（状态栏修改工具，简单、兼容性强支持4.4以及以上） ](https://github.com/guohaiyang1992/StatusBarControl)\n\n  * [ AppMarketHelper（应用市场辅助工具，简单、兼容性强 支持三星市场、腾讯应用宝、乐视 Tv Store） ](https://github.com/guohaiyang1992/AppMarketHelper/tree/master)\n\n","tags":["库"],"categories":["Github"]},{"title":"【Kotlin从入门到深坑】之类的属性和字段","url":"%2Fpost%2F8a29844e.html","content":"##  **简介**\n\n本篇博客主要是介绍Kotlin语法中的【类的属性和字段】相关的知识，帮助各位更快的掌握Kotlin，如果有疏漏或者错误，请在留言中指正，谢谢。 [\n系列汇总地址 ](http://blog.csdn.net/guohaiyang1992/article/details/72615889)\n\n* * *\n\n##  **基础知识**\n\n###  **定义**\n\n在讲解之前我感觉有很多人根本不清楚什么是属性，什么又是字段，我们先简单说明一下。\n\n简单理解：\n\n  * 字段，通常叫做类成员或者类成员变量，理解为”数据成员”，用来承载数据。 \n\n  * 属性，通常可以理解为set和get方法。其属名性时根据get和set方法名得出的，规则是：去掉get或set后其剩余的字符串，属性大多是对字段的封装，限制其访问和写入。 \n\n具体说明（以java为例）：\n\n  * 字段，在类中定义的成员变量。 \n``` \n         public class A{\n    private String s = \"123\";\n    }\n```\n\n我们可以描述为A类中有个s字段\n\n  * 属性，只局限于类中方法的声明，并不与类中其他成员相关。 \n```   \n        void setA(String s){}\n    String getA(){return s}\n```\n\n当一个类中拥有这样一对方法时，我们可以说，这个类中拥有一个可读写的a属性(注意是小写a)。如果去掉了 ` set ` 的方法，则是可读属性，反之亦然。\n\n总结一波：通过上面的介绍我们了解了什么是属性以及什么是字段，在 ` java ` 和 ` Kotlin ` 中其含义是一致的。\n\n* * *\n\n##  **属性和字段**\n\n###  **声明属性**\n\n对于Kotlin的类可以有属性。我们之前也说过可以通过 ` var ` 声明可变属性， ` val `\n声明只读属性，或许你会问了，为什么不是叫字段而是叫属性呢？因为 ` Kotlin ` 类中声明的变量，都会提供默认的 ` get ` 、 ` set `\n（val没有该方法）方法，所以声明的都是属性。 ` Kotlin ` 中没有字段，只有幕后字段（backing filed）。\n\n我们声明的时候大都采用下面的形式：\n\n    \n```    \n     class People {\n        var name: String? = null\n        var address: String = \"地球\"\n        var age: Int? = null\n    \n    }\n```\n\n你或许会说，属性是有get、set方法的（不仅限于此），那Kotlin自己实现的怎么用呢？\n\n    \n```    \n     var people=People() //声明实例，不需要new\n     people.name //直接使用，内部会调用访问方法\n```\n\n上面我们看到使用起来还是比较简单的。类似于我们 ` java ` 中声明了私有变量，然后提供了 ` set、get ` 方法，到达属性的目的。\n\n* * *\n\n###  **Getters和Setters**\n\n声明一个属性的完整语法如下：\n\n【属性修饰符（var、val）】+【属性名称】+ 【:】 + 【类型】 = 【初始化】  \n【gettter】  \n【setter】\n\n对于【初始化】和【getter】和【setter】都是可选的，如果通过【初始化】的值或者【getter】可以推断出类型，则【类型】也可以省略。\n\n属性通过 ` var ` 和 ` val ` 去声明得到只读属性和可变属性，那他们的区别究竟是什么呢？\n\n**只读属性和可变属性的区别：**\n\n  * 只读属性使用 ` val ` 声明，可变属性使用 ` var ` 声明 \n\n  * 只读属性不允许 ` setter `\n\n看到此处你或许会感叹 ` Kotlin ` 的厉害之处，省了不知多少时间，但有些人或许会感叹了，如果我想自己定义属性的访问方法又怎么弄呢？像 ` java\n` 再自定义方法吗？会不会和默认的 ` setter ` 或者 ` getter ` 冲突呢？对于疑问我们一一解答。\n\n* * *\n\n###  **自定义Getters和Setters**\n\n编写 ` Getters ` 和 ` Setters ` 非常像一般的不同方法，在属性声明内部，举例：\n\n**Getters方法：**\n\n    \n```   \n     var name: String? = null //声明name属性\n            get() {//重写get方法\n                return \"hhh\" \n            }\n    \n    \n     var people=People()\n     people.name\n```\n\n此处的 ` name ` 的值便是 ` hhh ` ,且无论 ` name ` 设置成什么值。\n\n**Setters方法：**\n\n    \n```    \n      set(value) {//错误写法\n         name=value //1)\n     }\n```\n\n在此不知道有没有人看出不对的地方，上面 1)\n处会导致循环调用，为什么呢？当你对属性赋值的时候就会调用set方法，当你获取属性的值得时候就会使用get方法。所以上面会一直循环调用set方法。\n\n下面我们看看正确的怎么写：\n\n    \n```    \n    set(value) {\n        field=value\n    }\n```\n\n看完上面的代码，你应该有两个疑问，1.value 是什么鬼，field 又是什么鬼。。。\n\n好，我们说明一下：\n\n  * ` value ` 是 ` setter ` 的参数，其类型同于属性的类型，不爽你也可以换个其他名字。。 \n\n  * ` field ` 就是我们之前说的幕后字段，用于将真正的值赋值给属性，而不会导致循环调用。它只能在属性的访问器中使用。这个也是可选项，有的时候必须（比如上面的Setter），有的时候不是必须（比如上面的Getter）。 \n\n如果上面的幕后字段仍然不能满足你…还有更猛的，幕后属性。\n\n    \n```   \n     private var _table: HashMap<String, String>? = null//私有属性\n     var table: HashMap<String, String>? = null \n        get() {\n                if (_table == null) {\n                    _table = HashMap<String, String>()\n                }\n                return _table //返回私有属性\n         }\n```\n\n上面的代码需要特殊说明一下，当属性被定义为 ` private ` 后其 ` Getter ` 和 ` Setter `\n，都是私有的，外部都不可以访问也就是说 ` person._table ` 是不允许的。也就进行了隐藏。又因为默认的 ` Setter ` 和 `\nGetter ` 调用私有属性会被进行优化，所以不会引入函数调用开销。\n\n* * *\n\n##  **编译期常量**\n\n在 ` kotlin ` 中已知值得属性可以使用 ` const ` 标记为编译期常量。\n\n**它需要满足以下条件：**\n\n  * 使用 ` val ` 声明的常量 \n  * 位于顶层或者 ` object ` 的一个成员 \n  * 用 ` String ` 或者原生类型值初始化 \n  * 没有自定义 ` Getter `\n\n* * *\n\n##  **延迟初始化属性**\n\n对于非空属性，在声明时必须对其进行初始化，如果想进行延迟初始化，可以使用 ` lateinit ` 标记，代码举例：\n\n    \n```    \n    lateinit  var name: String\n```\n\n**需要注意以下几点** ：\n\n  * 该修饰符只能用于类体中不是方法中的属性 \n  * 没有自定义 ` Setter ` 或者 ` Getter `\n  * 不能是原生类型（String可以，它不是原生类型） \n\n如果在初始前访问 ` lateinit ` 定义的属性会抛出特定异常，指明该属性没有被初始化。\n\n**总结一波** ：我们需要区分Kotlin中和java中使用属性的区别，对于 ` Koltin `\n中使用【类名.属性】等同于java中的【类名.属性对应方法】，以及牢记 ` Setter ` 的写法，别写错了，导致循环调用，熟练使用幕后字段。重写后的 `\nGetter ` 和 ` Setter ` 会覆盖之前的默认方法并不会冲突\n\n* * *\n\n##  总结\n\n至此已经学完了Kotlin的【类的属性和字段】的知识，多回顾多思考，继续 [ 后续内容\n](http://blog.csdn.net/guohaiyang1992/article/details/72615889) 。\n\n","tags":["属性"],"categories":["Kotlin"]},{"title":"解决某些Rom中EditText无法修改光标的问题","url":"%2Fpost%2Fe963c21e.html","content":"> 发现、探索、总结\n\n---\n# **简介**\n本篇博客主要讲如何解决某些`rom`下`EditText` 光标无法修改的问题。\n\n---\n# **现象**\n我们大都遇到过这种情况，由于为了保证App整体的一致性，Ui 有时候会让你修改某些光标的显示颜色，你或许会说这有什么难的？一句代码搞定，代码如下：\n\n```\napp:textCursorDrawable=\"@drawable/xx\"\n```\n结果你运行在模拟器上，喜滋滋的看着自己的成果，但是后面测试仍然找到了你，说你仍没有修改，这时候的你一脸懵逼。你要去找测试理论，测试拿出了他的**华为手机** ...，你或许会感叹，这很华为...\n\n对于某些国产`rom` ，类似华为、小米、魅族它们对系统源码进行了修改，某些情况下会导致系统的`api`无效，但经过实践发现，修改光标最终修改的只是`mCursorDrawableRes`对应的值，即使在国产`rom`也是如此，所以有了后面的解决办法。\n\n---\n\n# **解决办法**\n\n通过上面的现象和实践我们知道只需要能够修改`mCursorDrawableRes`对应的值就可以保证兼容这些系统，如何去修改呢？\n\n 具体思路如下： 利用反射获取对应的成员变量，然后将自己需要传入的值进行设置\n\n具体步骤：\n      \n\n 1. 继承`EditText`\n \n 2. 声明自定义的属性，用于接收自定义的值\n\n 3. 利用反射将用户定义的值进行设置\n\n---\n\n# **简单方式**\n\n你或许会说我难不成还要自己去自定义吗？而且感觉每次都这样写好麻烦啊！ 好吧，程序员怎么可以这么low,使用下面的方式即可轻松上车... 滴滴.\n \n - 导入该库\n\n\nStep 1. Add it in your root build.gradle at the end of repositories:\n```\n  allprojects {\n    repositories {\n      ...\n      maven { url 'https://jitpack.io' }\n    }\n  }\n```\nStep 2. Add the dependency\n\n  \n\n```\ndependencies {\n          compile 'com.github.guohaiyang1992:GeneralEditText:0.2'\n  }\n```\n\n\n \n\n - 使用该库的控件`com.ghy.ui.GeneralEditText`\n\n - 使用`app:textCursorDrawable=\"@drawable/xx\"`\n  \n\n如果你想看具体的实现，请跳转至[github](https://github.com/guohaiyang1992/GeneralEditText)\n\n---\n# **总结**\n至此已经完成了修改光标的学习。遇到问题多思考。","tags":["修改颜色"],"categories":["Android"]},{"title":"【Kotlin从入门到深坑】之类的覆盖属性和方法以及抽象类","url":"%2Fpost%2F1802126c.html","content":"##  **简介**\n\n本篇博客主要是介绍Kotlin语法中的【类的覆盖属性和方法以及抽象类】相关的知识，帮助各位更快的掌握Kotlin，如果有疏漏或者错误，请在留言中指正，谢谢。\n[ 系列汇总地址 ](http://blog.csdn.net/guohaiyang1992/article/details/72615889)\n\n* * *\n\n上一篇博客中我们详细介绍了类的继承和构造，下面我们来讲一下，在继承时如何覆盖方法。\n\n* * *\n\n##  **覆盖方法**\n\n我们先看一下如何去写，例子如下：\n\n    \n```   \n     // 父类，使用open关键词\n    open class TestB {\n       open fun test() { //需要被重写的方法需要使用open修饰\n    \n        }\n    }\n    //子类\n    class TestA() : TestB() {\n        override fun test() {//重写的方法需要使用override\n            super.test()\n        }\n    }\n```\n\n方法和类一样，默认是final的禁止重写的，所以必须加上 ` open ` 修饰，而重写的方法也必须加上 ` override `\n,否则子类不允许相同签名的函数。\n\n还有一点是需要注意的，默认 ` override ` 的函数是 ` open ` 的，如果你想再次限制它被覆盖，可以使用 ` final `\n修饰，代码如下：\n\n    \n```    \n    //子类\n    class TestA() : TestB() {\n        final override fun test() {//重写的方法需要使用override，使用了final，后续无法覆盖\n            super.test()\n        }\n    }\n```    \n\n* * *\n\n##  **覆盖属性**\n\n我们先看一下如何去写，例子如下：\n\n    \n```   \n     //父类\n    open class TestB {\n    \n       open var x: Int? = null //属性x\n            get() {//重写了get方法，此处后面详解\n                field = 34\n                return field\n            }\n    }\n    \n    class TestA() : TestB() {\n        override var x: Int?=null //它覆盖对应属性后，对应的方法也被覆盖\n    \n    \n    }\n```\n\n对于Kotlin中的属性都有默认的get、set方法，当然也可以重写，比如上面的 ` TestB ` 的x的属性的 ` get ` 方法被重写了。但是 `\nTestA ` 覆盖属性后， ` TestB ` 中定义的 ` get ` 方法对其无效，举例如下，便于理解其含义：\n\n    \n```    \n     var a = TestA()\n        println(a.x)\n    \n        var b=TestB()\n        println(b.x)\n```\n输出结果：\n\n    \n```    null  //说明TestB的get方法对TestA类无效\n    34   //说明TestB的get方法对TestB类有效\n```\n\n注意：如果原类型为 ` var ` ,则覆盖类型可以为 ` var ` ，且不可以是 ` val ` ,如果原类型是 ` val ` ,覆盖类型可以是 `\nval ` ,也可以是 ` var `\n\n* * *\n\n##  **多实现**\n\n在Kotlin中，对于继承来说，如果一个类从它的直接超类继承相同成员的多个实现，它必须覆盖这个成员并提供自己的实现。为了表达\b采用从哪个超类型继承实现，我们使用\n` super<父类名> ` ，下面举例说明：\n\n    \n```   \n     //首先声明一个类\n    open class TestB {\n    \n       open var x: Int? = null\n            get() {\n                field = 34\n                return field\n            }\n    \n        open fun test() { //此处有一个可以覆盖的方法test()\n    \n        }\n    \n    \n    }\n    \n    \n    //声明一个接口\n    interface TestC { //这个是接口的声明方式\n        var x: Int? //声明了一个抽象字段，实现类必须覆盖此属性\n        fun test() { //声明了一个方法，这个是特殊的，可以有实现方法\n            print(\"d\")\n        }\n    \n        fun test2() //这个是和java一致的抽象方法\n    }\n```\n\n此处需要注意此处的接口是可以实现具体的方法的\n\n    \n```    \n    //实现类TestA\n    class TestA() : TestC, TestB() {\n    \n        override fun test2() {//对于一般的抽象方法等同于java中，必须实现，否则声明成抽象类\n    \n        }\n    \n        override fun test() {//此处必须写，因为test有两种不同实现\n            super<TestC>.test()\n            super<TestB>.test()\n            //上面两个都可不写,也可以都写，类似于super.method\n    \n        }\n    \n        override var x: Int? = null //对于字段没影响，因为接口的属性不允许赋值,\n    \n    \n    }\n```\n\n我们总结一波：\n\n  * 首先继承 ` TestB ` 、 ` TestC ` 是正常的 \n  * 由于 ` TestB ` 、 ` TestC ` 内都有 ` test ` 方法，所以 ` TestC ` 必须实现 ` test ` 方法 \n  * 在子类 ` TestC ` 中使用 ` super<TestB>.test() ` 或者 ` super<TestC>.test() ` 来调用父类的实现 \n\n上面我们说的是方法，仔细的话，我们还能看到接口还有属性的定义,对于 ` TestB ` 和 ` TestC ` 都有 ` x ` 字段， ` TestA `\n中进行重写的话，get/set都会被覆盖，所以不会出现上面方法的问题\n\n还需要注意，看一下代码\n\n    \n```    \n    open class TestB {//类的一个成员变量\n        open var x: Int? = null\n    }\n    \n    interface TestC { //这个是接口的声明方式\n        var x: Int? //声明了一个抽象字段，实现类必须覆盖此属性\n    \n    }\n    \n    //实现类\n    class TestA() : TestC, TestB() {\n    }\n```\n\n我们总结一波：\n\n  * 对于接口来说，他的方法默认是抽象的，除非自己实现了 \n  * 对于接口的成员变量也是一样的，也是默认抽象的，子类必须覆盖 \n  * 但凡事都有例外，对于上面的实现中，我们并没覆盖 ` x ` ,但仍然正确是，因为，接口只是约束作用，因为 ` TestA ` 继承了 ` TestB ` ,也就有了 ` X ` ，字段，而接口也就是约束必须有该字段即可，所以，上面的实现也是允许的 \n\n* * *\n\n##  **抽象类**\n\n类和类中的某些成员可以声明成 ` abstract `\n,抽象成员在本类中可以不去实现，需要注意的是我们不需要用open标注抽象类或者函数，更有趣的是看如下实现：\n\n    \n```    \n     //开放的类和方法\n    open class A{\n        open fun  test(){\n    \n        }\n    }\n    //抽象类\n    abstract class B : A() {\n        abstract override fun test() //抽象方法覆盖开放方法\n    }\n```\n\n我们可以用一个抽象成员去覆盖一个非抽象的开放成员\n\n* * *\n\n##  **伴生对象**\n\n与java不同，Kotlin没有静态方法，官方建议使用包级函数，可以使用如下两种方式来实现类似静态类、静态方法的方式  \n第一种：\n\n    \n```    \n     object StaticDemo{\n        fun test(){\n            print(\"\")\n        }\n    }\n```\n\n使用方法如下：\n\n    \n```    \n      StaticDemo.test()\n```    \n\n第二种：\n\n    \n```    \n    class Demo {\n        companion object {//声明在内部的，类似静态方法，可以使用 类名.方法名\n            fun test() {\n                print(\"\")\n            }\n        }\n    \n        fun test2() { //test2在外部，必须实例化后才可调用\n    \n        }\n    \n    }\n```\n\n使用方法：\n\n    \n```    \n      Demo.test()\n```\n\n* * *\n\n下面我们总结一波：\n\n  * 无论方法还是类除了抽象类、抽象方法、接口、接口方法外，其他的继承都需要写 ` open ` ,重写的成员变量和方法需要 ` override `\n\n  * 与java不同，Kotlin中的接口可以自己实现方法，从而导致了出现多实现的问题，出现多实现的，继承的子类需要重写对应的方法，然后决定是否或者调用哪个父类的方法。 \n\n* * *\n\n##  **总结**\n\n至此已经学完了Kotlin的【类的覆盖属性和方法以及抽象类】相关的知识，多回顾多思考，继续 [ 后续内容\n](http://blog.csdn.net/guohaiyang1992/article/details/72615889) 。\n\n","tags":["继承"],"categories":["Kotlin"]},{"title":"【Kotlin从入门到深坑】之返回和跳转","url":"%2Fpost%2Fcb6db1c3.html","content":"##  **简介**\n\n本篇博客主要是介绍Kotlin语法中的【返回和跳转】相关的知识，帮助各位更快的掌握Kotlin，如果有疏漏或者错误，请在留言中指正，谢谢。 [ 系列汇总地址\n](http://blog.csdn.net/guohaiyang1992/article/details/72615889)\n\n* * *\n\n##  **返回和跳转**\n\nkotlin中有三种结构化跳转表达式：\n\n  * **return:** 默认从直接包围的函数或匿名函数返回。 \n  * **break:** 终止最直接包围它的循环。 \n  * **continue:** 继续下次最直接包围它的循环。 \n\n从上面的介绍中我们可以看出，和java是一致的，在此不再赘述，下面介绍点特殊用法。\n\n* * *\n\n###  **标签**\n\n在Kotlin中任何表达式都可以用标签来标记。标记的格式为：标识符+@，例如， ` abc@ ` 。如果想为一个表达式加标签，可按照如下方式去写：\n\n    \n```   \n     loop@ if (true){ //在表达式的前面加标签\n    \n        }\n```\n\n* * *\n\n###  **break和continue标签**\n\n对于 ` break ` 和 ` continue ` 默认情况下只影响最直接包围它的循环，想跳出多层循环就不可以了，但是加上标签效果便不在一样，代码如下:  \n示例1，break标签：\n\n    \n```   \n     loop@ for (i in 1..10) {\n            for (j in 1..10) {\n                if (j == 2) {\n                    break@loop\n                }\n                println(i.toString() + \":\" + j.toString())\n            }\n        }\n```\n\n此时的输出如下：\n\n    \n```  \n    1:1\n```\n\n通过结果我们可以看出， ` break ` +标签 可以跳到标签的位置，且跳转到标签指定的循环后面的执行点。 如果使用 ` continue `\n,会有怎样的变化？\n\n    \n```   \n    loop@ for (i in 1..10) {\n            for (j in 1..10) {\n                if (j == 2) {\n                    continue@loop //只是修改此处\n                }\n                println(i.toString() + \":\" + j.toString())\n            }\n        }\n```\n\n结果如下：\n\n    \n```   \n    1:1\n    2:1\n    3:1\n    4:1\n    5:1\n    6:1\n    7:1\n    8:1\n    9:1\n    10:1\n```\n\n从结果我们可以看出， ` continue ` +标签 跳转到循环的下一次迭代。\n\n* * *\n\n###  **return 标签**\n\nKotlin 有函数字面量、局部函数和对象表达式（ **函数相关后续会专门详细解释** ）。因此 Kotlin 的函数可以被嵌套。 标签限制的 return\n允许我们从外层函数返回。 最重要的一个用途就是从 lambda 表达式中返回。示例如下：\n\n    \n```   \n    fun foo() {\n        ints. forEach {\n            if (it == 0) return\n            print(it)\n        }\n    }\n```\n\n这个 ` return ` 表达式从最直接包围它的函数即 ` foo ` 中返回。 （注意，这种非局部的返回只支持传给内联函数的 ` lambda `\n表达式。） 如果我们需要从 ` lambda ` 表达式中返回，我们必须给它加标签并用以限制 ` return ` 。\n\n    \n```    \n    fun foo() {\n        ints.forEach lit@ { //注意此处的位置\n            if (it == 0) return@lit\n            print(it)\n        }\n    }\n```\n\n现在，它只会从 ` lambda ` 表达式中返回。通常情况下使用隐式标签更方便。 该标签与接受该 ` lambda ` 的函数同名。\n\n    \n```   \n    fun foo() {\n        ints.forEach {\n            if (it == 0) return@forEach\n            print(it)\n        }\n    }\n```\n\n或者，我们用一个匿名函数替代 ` lambda ` 表达式。 匿名函数内部的 ` return ` 语句将从该匿名函数自身返回\n\n    \n```    \n    fun foo() {\n        ints.forEach(fun(value: Int) {\n            if (value == 0) return\n            print(value)\n        })\n    }\n```\n\n当要返一个回值的时候，解析器优先选用标签限制的 ` return ` ，即\n\n    \n```   \n    return@a 1\n```\n\n其含义为“从标签 @a 返回 1”，而不是“返回一个标签标注的表达式 (@a 1)”\n\n* * *\n\n##  **补充**\n\nKotlin中有许多简便的表达式，下面我们介绍一下。\n\n* * *\n\n###  **if not null**\n\n代码说明：\n\n    \n```    \n        //if not null\n        var data: ArrayList<String>? = ArrayList<String>() //此时不为null\n        println(data?.size) //输出： 0\n        data = null //此时为null\n        println(data?.size) //输出： null\n```\n\n总结： ` data?.size ` 表达式的意思是：如果 ` data ` 不是 ` null ` ,则输出 ` data.size ` 反之如果是 `\nnull ` 则返回 ` null `\n\n* * *\n\n###  **if null**\n\n代码说明：  \n\b\n\n    \n```   \n      data = null //此时为null\n     println(data ?: \"这个是空的\") //输出：这个是空的\n     data =1\n     println(data ?: \"这个是空的\") //输出：1\n```   \n\n总结： ` data?:\"测试\" ` 表达式的含义是：如果 ` data ` 是 ` null ` 则运行 ` ： ` 后的语句或者方法，反之则返回 `\ndata ` 自身。\n\n* * *\n\n###  **if not null else= > if null(if not null) **\n代码说明： \n\n```   \n        data = null //此时为null\n        println(data?.size ?:\"这个是空的。。。\")\n         data = ArrayList<String>()//不为null\n        println(data?.size ?:\"这个是空的。。。\")\n```\n\n总结：从标题我们就可以看出，这个可以理解为上面的两个表达式的合集， ` data?.size ?:\"这个是空的。。。\" ` 表达式的含义是：如果 `\ndata ` 不是 ` null ` 则返回 ` data.size ` ,如果是 ` null ` 则运行 ` ： ` 后的语句或者方法。\n\n换个思路去想：首先表达式总体上是个if null-> ` object?:\"测试\" ` ，而object-> if not null-> `\ndata?.size ` ,这样就比较好理解了，当 ` data ` 为 ` null ` 的时候， ` if not null ` ,返回 `\nnull（object为null） ` ,又因为 ` if null ` ，所以会执行 ` ： ` 后的内容，反之不是 ` null ` ,则会执行 `\ndata.size ` ,又因为 ` if null ` 条件不满足，所以后续不会执行。\n\n* * *\n\n###  **if not null 然后执行代码**\n\n代码说明：\n\n    \n```    \n    data?. let {  //如果data不为null会自行let代码块内的内容\n            println(\"data不为null，执行此处\")\n        }\n```\n\n* * *\n\n##  **总结**\n\n至此已经学完了Kotlin的【返回和跳转】相关的知识，多回顾多思考，继续 [ 后续内容\n](http://blog.csdn.net/guohaiyang1992/article/details/72615889) 。\n\n","tags":["标签"],"categories":["Kotlin"]},{"title":"【kotlin从入门到深坑】之类和继承","url":"%2Fpost%2Fe05a8e4d.html","content":"##  **简介**\n\n本篇博客主要是介绍Kotlin语法中的【类和继承】相关的知识，帮助各位更快的掌握Kotlin，如果有疏漏或者错误，请在留言中指正，谢谢。 [ 系列汇总地址\n](http://blog.csdn.net/guohaiyang1992/article/details/72615889)\n\n* * *\n\n##  **类**\n\n###  **声明类**\n\nKotlin中使用关键词class 声明类和java中保持一致，代码如下：\n\n    \n```   \n     class Demo{ //class + 类名\n    \n    }\n```\n\n类的构成=class +类名+类头（可选）+类体（可选），如果没有类体，括号也可省略\n\n    \n```    \n    class Demo //class + 类名\n```\n###  **主构造函数**\n\n在Kotlin的类中可以有一个主构造函数和多个次构造函数。我们看看什么样的算主构造函数，例子如下：\n\n    \n```    \n     class Demo(){\n    \n    }\n```\n\n看了例子估计心里开始有疑惑了，这和上面的例子有什么不同？？仔细一看还真有不同，多了”（）”，这就声明了一个无参的主构造函数，当然你也可以声明有参数的，如下\n\n    \n```    \n    class Demo(name: String){\n    \n    }\n```\n主构造函数只是类头的一部分，还有一个可选关键词– **constructor** ，当主构造函数想声明为非public\n类型的时候，需要使用该关键词其他时候可以省略，例如：\n\n    \n```    \n     class Demo private constructor(name: String){\n    \n    }\n```\n\n这种情况一般是在写单例的时候会用到。\n\n构造函数都有了，我们可以愉快的做些初始化了，但是但是要注意， **主构造函数内不能包含任何代码。** 这个时候我们需要使用另一个关键词 ` init `\n,使用 ` init ` 代码块进行初始化代码即可，如下：\n\n    \n```    \n     class Demo private constructor(name: String) {\n        init {//init代码块\n            println(\"测试输出\")\n        }\n    }\n```\n\n上面的代码中 ` name ` 可以直接使用在 **` init ` 代码块内和类体内声明的属性初始化中使用 ** ，只有这两种情况，代码如下\n\n    \n```    \n     class Demo (name: String) {\n        init {\n            println(\"测试输出\"+name) //在此处使用可以\n        }\n        var nameTest=name //此处给nameTest赋值可以，但不可以单独使用\n    }\n```\n\n当然我们可以让上面的 ` name ` 有更多的用途怎么办呢？可以这样写：\n\n    \n```    \n    class Demo(var name: String) { //此处加入 var关键词\n        init {\n            println(\"测试输出\" + name)\n        }\n    \n        var nameTest = name\n    \n        fun printTest() { //方法内也可使用了\n            println(name)\n        }\n    }\n```\n\n不仅可以使用 ` var ` 关键词，还可以使用val，具体的差别之前我们说过，再次不再赘述。  \n使用该关键词后，name就等同于是该类的成员变量，就等同于你直接声明在类中。  \n对于Kotlin来说还有个好用的地方，就是你声明的类中变量不需要写get/set方法，默认就会有，可以直接用。\n\n###  **次构造函数**\n\nKotlin中类也可以声明前缀有 constructor 的 **次构造函数** ,如下：\n\n    \n```    \n     class Demo { //有个默认的无参主构造函数\n      constructor(){// 有个无参次构造函数\n    \n      }\n    }\n```\n\n**如果类有一个主构造函数，每个次构造函数需要委托给主构造函数， 可以直接委托或者通过别的次构造函数间接委托。委托到同一个类的另一个构造函数 用 this\n关键字即可** 。\n\n下面根据主构造函数是否重写来分别讲解，先说未重写:\n\n    \n```    \n     class A{\n    \n    }\n```\n\n如何写它的次构造函数呢？\n\n    \n```    \n    class A {\n        init {\n            println(\"--A主构造--\")\n        }\n    \n        constructor(name: String) { //此处屏蔽了 默认的主构造函数\n            println(\"--A次构造--\")\n    \n        }\n    }\n```\n\n上面的写法会导致Kotlin的默认无参主构造函数不可调用, 也就导致 ` constructor(name: String)：this() `\n失效，但我们上面说过必须要委托给主构造函数，这怎么办？其实Kotlin内部仍然会走默认的主构造函数，也就是说\n**如果是默认主构造是可以省略不写的，有的时候是想写也没法写** 。\n\n得到上面的结论是源于一个测试，代码如下：\n\n    \n```    \n     var a = A(\"name\"); //此处已经无法调用无参的，也就是默认的主构造失效，内部使用this(） 也是不可以的\n```\n后面的打印结果\n\n    \n```    \n    --A主构造--   //仍然走了主构造函数，此时只有默认主构造函数\n    --A次构造--   //然后再走次构造\n```\n所以得到上面的结论，在此佐证。 **后续用实际代码详解，此处挖坑** 。\n\n有的筒子可能就会想了，如果我们仍然想要一个无参数的构造函数怎么写？\n\n    \n```    \n     class A {\n        init {\n            println(\"--A主构造--\")\n        }\n    \n        constructor(name: String) {\n            println(\"--A次构造--\")\n    \n        }\n    \n        constructor(){ //增加一个无参的次构造函数\n    \n        }\n    }\n```\n还有另一个方式，就是重写主构造函数，这两种方法都类似\njava中自己重写一个无参的构造函数，现在就是区分了主、次构造函数的重写。还需强调的是主构造如果重写了，次构造不允许再重写。下面写个重写主构造函数的，后面细说：\n\n    \n```    \n    class A() { //重写此处\n        init {\n            println(\"--A主构造--\")\n        }\n    \n        constructor(name: String) : this() {\n            println(\"--A次构造--\")\n    \n        }\n    \n    //    constructor(){ //次构造不允许使用\n    //        \n    //    }\n    }\n```\n下面我们讲一下重写主构造函数的  \n如下：\n\n    \n```    \n    class Demo() { //没参数的主构造函数\n        constructor(name: String) : this() { //次构造函数委托给\n        }\n    }\n```\n\n此处就和默认的不一样了，这个地方需要使用this()，因为你重写了主构造函数。如果不重写是可以不写this（）\n\n通过上方的各种对比和例子我们对类的构造函数有了大概的了解，我们为了方便理解在这里总结一波，还有不明白的多看看例子：\n\n  * 类只有一个主构造函数，但可以有一个或多个次构造函数 \n\n  * 次构造函数需要委托给主构造函数，可以通过直接或者间接的方式 \n\n  * 在声明期间，以主构造函数为主，如果主构造函数 **重写** 了对应的构造方法，次构造函数不能用重复的出现对应的构造函数，上面有例子说明。 \n\n  * 在调用期间，以次构造函数为主，如果未重写主构造函数，默认会有一个无参的主构造函数，如果重写一个无参次构造函数，则可调用的只有次构造函数。 \n\n###  **创建类的实例**\n\n要创建一个类的实例，我们就像普通函数一样调用构造函数：\n\n    \n```    \n     val invoice = Invoice()\n    val customer = Customer(\"Joe Smith\")\n    //注意 Kotlin 并没有 new 关键字。\n```\n\n##  **继承**\n\n在 Kotlin 中所有类都有一个共同的超类 Any，这对于没有超类型声明的类是默认超类：\n\n    \n```    \n     class Example // 从 Any 隐式继承\n```\n\nAny 不是 java.lang.Object；尤其是，它除了 equals()、hashCode()和toString()外没有任何成员。\n更多细节请查阅Java互操作性部分。\n\n要声明一个显式的超类型，我们把类型放到类头的冒号之后：\n\n    \n ```   \n    open class A(p: Int) //注意此处的 open 关键词\n    \n    class B(p: Int) : Base(p) //使用\" ：\"\n```\n\n**对于继承的类来说，它仍需满足之前类中主次构造函数的规定，还需满足继承类委托给被继承类的主构造函数（保证对应类的init模块都能运行的关键），此处的被委托的主构造函数如果是无参构造函数，可以省略不写**\n\n下面我们分两种类型去分别讲解，首先是未修改默认的主构造函数的情况：  \n我们先看一下被继承类：\n\n    \n```    \n    open  class BB { //未重写默主构造\n    \n        constructor(name: String) {\n            println(name + \"---BB\")\n        }\n    \n    \n        constructor() {\n            println(\".....---BB\")\n    \n        }\n    }\n```\n\n继承类：\n\n    \n```   \n    class testA : BB { //此处testA也没重写主构造\n        constructor(name: String) : super(name) {//--    1)\n            println(\"A---\" + name)\n        }\n    \n        constructor() {//--  2)\n            println(\"A---\" + \"ss\")\n        }\n    }\n```\n\n位置1处的构造函数，因为未重写主构造，所以本类的委托完成，所以只需委托父类即可，即可满足上面说的要求。\n\n位置2处的构造函数，因为未重写主构造，所以本类的委托完成，又因为默认是委托父类的无参主构造函数（系统默认的或者重写的都满足），所以满足上面说的要求。\n\n我们做下改动，将B 改动如下：\n\n    \n```    \n    open class BB() {//重写默认主构造\n    \n        constructor(name: String):this() { //手动委托主构造\n            println(name + \"---BB\")\n        }\n    \n    \n    //    constructor() { //根据主次函数关系，此处无法存在\n    //        println(\".....---BB\")\n    //\n    //    }\n    }\n```\n\n这时候我们的继承类如何写呢？\n\n    \n```    \n    class testA : BB {\n        constructor(name: String) : super(name) {\n            println(\"A---\" + name)\n        }\n    \n        constructor() {\n            println(\"A---\" + \"ss\")\n        }\n    }\n```\n\n可以看到代码是没变化的，也就是说，只要是被继承类的主构造函数，是无参的，无论是默认还是重写都可以省略不写，当然也可以写上\n\n    \n```    \n    class testA : BB {\n        constructor(name: String) : super(name) {//可以选择不同的父类的主构造函数进行委托\n            println(\"A---\" + name)\n        }\n    \n        constructor():super() {//无参的委托\n            println(\"A---\" + \"ss\")\n        }\n    }\n```\n\n下面我们将一下修改默认主构造函数的情况\n\n    \n```    \n    class testB(name: String) : BB(name) { //此处testB重写了默认主构造，所以此处B一定需要用主构造函数（直接或间接的）\n        init {\n            println(name + \"99ss...---B\")\n        }\n    \n        constructor(name: String, age: Int) : this(name) {\n            println(name + \"...---B\")\n        }\n    }\n```\n\n也可以这样写：\n\n    \n```    \n    class testB(name: String) : BB() { //此处必须有\"（）\"\n        init {\n            println(name + \"99ss...---B\")\n        }\n    \n        constructor(name: String, age: Int) : this(name) {  //此处不能使用super了，不能重复委托父类，主构造函数已经委托过了\n            println(name + \"...---B\")\n        }\n    }\n```\n\n下面我们总结一波：\n\n  * 如果继承的类重写了默认主构造函数，此时必须用基类的主构造函数初始化（直接或间接） \n\n  * 如果继承的类没重写默认的主构造函数，此时可以使用super关键词初始化，我们也说过，未重写的的默认主构造函数，次构造函数都会委托给它，所以本类内也满足了委托条件，对于类外，也委托了被继承类的主构造方法，完成了两个类的条件 \n\n* * *\n\n##  总结\n\n至此已经学完了Kotlin的类和继承相关的知识，多回顾多思考，继续 [ 后续内容\n](http://blog.csdn.net/guohaiyang1992/article/details/72615889) 。\n\n","tags":["继承"],"categories":["Kotlin"]},{"title":"【kotlin从入门到深坑】之语句","url":"%2Fpost%2F74742d5b.html","content":"\n## **简介**\n本篇博客主要是介绍Kotlin语法中的【语句】相关的知识，帮助各位更快的掌握Kotlin，如果有疏漏或者错误，请在留言中指正，谢谢。 [系列汇总地址](http://blog.csdn.net/guohaiyang1992/article/details/72615889)\n\n---\n##**准备**\n在学习之前我们先有点基础知识上的认识，如下：\n\n - `Kotlin`中函数使用`fun` 关键词声明。\n\n---\n\n## **条件语句**\n### **if表达式**\n在`Kotlin`中`if`是表达式，也就是说不需要三目运算符了，因为`if`本身就支持。下面举例说明：\n\n```\nval max = if (a > b) a else b  //a=1，b=2, max=b=2  ，返回b的值给max\n```\n总结:`Kotlin`中`if`更加智能，不需要判断分行，如果满足条件则执行if和else之间的语句，反之执行else后的语句，不过**不使用\"{}\"时，if或else后只能写一个语句**,我们还观察到**if表达式返回的是变量值（不同于函数需要return关键词），其实也支持有返回值的函数**。\n\n如果在执行的时候，想执行更多的语句，还需要去写\"{}\"。细心的朋友或许会发现一个问题，当前使用了\"{}\",如果出现了多个变量值或者有返回值的函数，其结果究竟是什么呢？会如同return一样吗，阻断后续代码的执行？下面我们通过例子讲解：\n\n```java\n//比较两个值大小\nfun ifDemo2(a: Int, b: Int) { //--函数的概念后续再讲，目前按照java的函数理解即可\n    var max = if (a > b) {\n        a\n        stringDemo(3)\n    } else {\n        numberDemo(4)\n        b\n    }\n\n    println(max)\n}\n//返回输入的值 --Int\nfun numberDemo(c: Int): Int {\n    return c\n}\n//返回对应值的对应内容--String\nfun stringDemo(c: Int): String {\n    return c.toString() + \"sd\"// 注意此处不能直接 c+\"sd\",java中允许，Kotlin中不允许\n}\n```\n**测试：**\n\n - `ifDemo2(1，2)` ,结果 `2`\n - `ifDemo2(2，1)`,结果 `3sd`\n\n**总结：**\n对于if表达式，其返回的内容类型可以不相同，对于可返回值的函数也同样支持，且其返回的内容仅和其顺序有关，并不会阻断后续代码的执行。\n\n---\n### **when表达式**\n在`Kotlin`中`when`取代了`java`中得`switch`方法，且功能更加强大支持各种类型。下面举例说明：\n\n```\nfun whenDemo(a: Any) {//Any 类似java中的Object\n\n    when (a) { \n    \n        1 -> println(\"选择的1\")//使用\"->\"来表示分支 --Int\n        \n        \"2\" -> { //多行语句需要使用\"{}\" --String\n            println(\"选择『2』\")\n        }\n        true -> { //--Boolean\n            println(\"选择true\")\n        }\n        in 0..9 -> {// in 表示是否在range中 --后续会讲\n            println(\"在0-9之内\")\n        }\n        is String -> { //is表示是否是某种类型，类似java中instanceOf() --后续会讲\n            println(\"是字符串\")\n        }\n        numberDemo(3) -> { //支持有返回值的函数\n            println(\"选择3\")\n        }\n        10, 11 -> { //当两个条件都执行相同代码时这样写\n            println(\"等于10或者11\")\n        }\n        else->{\n          printLn(\"类似default\") //类似switch中的default\n        }\n\n    }\n}\n```\n总结：`when`相比于`switch`可以支持不同类型的分支语句，其中`else`类似`default`需要放在最后且只能有一个。\n\n---\n\n## **循环语句**\n### **for循环**\n`Kotlin`中`for` 循环可以对任何提供迭代器（`iterator`）的对象进行遍历，语法如下:\n\n```\nfor (item in collection)\n    print(item)\n```\n\n循环体可以是一个代码块。\n\n```\nfor (item: Int in ints) {\n  // ...\n}\n```\n这个时候你可能就会问了，什么样的对象提供了迭代器，满足下面的条件之一即可：\n\n- 有一个成员函数或者扩展函数 `iterator()`，它的返回类型\n- 有一个成员函数或者扩展函数 `next()`，并且\n- 有一个成员函数或者扩展函数 `hasNext()` 返回 `Boolean`。\n\n当然有人或许会问，我想使用之前的`for(int i=0;i<list.size;i++)` 的形式遍历呢，需要得到索引，当然`Kotlin`也是支持的，代码如下：\n\n```\nfor (i in array.indices) //注意此处不需要声明i,默认是Int\n  print(array[i]) //可以通过索引获取内容\n```\n甚至可以让你体会到遍历`map`时的感觉\n\n```\nfor ((index, value) in array.withIndex()) { //索引(Int)和值(Any)\n    println(\"the element at $index is $value\")\n}\n```\n\n此处补充一个关于数组的知识，对于数组的创建我们都很熟悉了，但是下面的你见过吗？\n\n```\n var array = arrayOf(\"1\", \"2\", 3, 4) //可以是不同类型的哦，这个和python一致\n```\n这个也可以进行遍历，不过`value`需要使用`Any`，此处需要注意哦。此处的数据保存也是按照`Any`保存。\n\n---\n### **while循环**\n`while` 和 `do..while` 照常使用\n```\n\nwhile (x > 0) {\n  x--\n}\n\ndo {\n  val y = retrieveData()\n} while (y != null) // y 在此处可见\n```\n\n\n\n\n---\n##**总结**\n至此已经学完了`Kotlin`的【语句】相关的知识，多回顾多思考，继续[后续内容](http://blog.csdn.net/guohaiyang1992/article/details/72615889)。","tags":["条件"],"categories":["Kotlin"]},{"title":"【kotlin从入门到深坑】系列目录","url":"%2Fpost%2F6a493b88.html","content":"#  **Kotlin**\n\n* * *\n\n【Kotlin从入门到深坑】让你从对kotlin一无所知到「有所思有所得」\n\n本教程是一系列介绍kotlin 的相关语法的教程，后续还有专门讲解kotlin for android 相关的教程。如果内容中出现错误，请留言指正，感谢。\n\n###  **目录**\n\n  * [ 基础类型 ](http://blog.csdn.net/guohaiyang1992/article/details/72615715)\n\n  * [ 语句 ](http://blog.csdn.net/guohaiyang1992/article/details/72630516)\n\n  * [ 返回和跳转（讲解kotlin的返回和跳转） ](http://blog.csdn.net/guohaiyang1992/article/details/72823992)\n\n  * [ 类和继承 ](http://blog.csdn.net/guohaiyang1992/article/details/72766180)\n\n  * [ 类的覆盖属性和方法以及抽象类 ](http://blog.csdn.net/guohaiyang1992/article/details/72904421)\n\n  * [ 类的属性和字段 ](http://blog.csdn.net/guohaiyang1992/article/details/73136018)\n\n###  **其他**\n\n  * [ github观看 ](https://github.com/guohaiyang1992/kotlin)\n\n","tags":["文档"],"categories":["Kotlin"]},{"title":"【Kotlin从入门到深坑】之基础类型","url":"%2Fpost%2F853f2571.html","content":"##  **简介**\n\n本篇博客主要是介绍Kotlin语法中的【基础类型】相关的知识，帮助各位更快的掌握Kotlin，如果有疏漏或者错误，请在留言中指正，谢谢。 [ 系列汇总地址\n](http://blog.csdn.net/guohaiyang1992/article/details/72615889)\n\n* * *\n\n##  **准备**\n\n在学习之前我们先有点基础知识上的认识，如下：\n\n  * Kotlin和java代码可以混合写，也可以互调。 \n\n  * Kotlin中是不写 ` ; ` 的。 \n\n  * Kotlin中使用关键词val表示常量，var表示变量 \n\n  * Kotlin中声明变量的模板 ` var a:Int =1 => var 变量名:类型 = 值 `\n\n* * *\n\n##  **基本类型**\n\n对于java中我们都很清楚基本类型有 byte、short、int、long、double、float、boolean、char\n等，对于Kotlin中当然也有与其对应的，不过它们更像是java中的包装类 比如 ` int->Integer ,Kotlin中是Int `  \n下面是对应关系( _首字母变大写_ )  \n\\- ` int->Int `  \n\\- ` double->Double `  \n\\- ` long->Long `  \n\\- ` double->Double `  \n\\- ` float->Float `  \n\\- ` boolean->Boolean `  \n\\- ` char->Char `\n\n对于Kotlin中所有东西都是对象，也就是说我们可以在任何变量上面调用属性和成员变量。\n\n* * *\n\n##  **数字**\n\n对于Kotlin数字的处理和java类似，但也略有不同，比如没有隐式拓宽转换（对于java中int类型的可以转为long类型的），数字的表示上和java的类似，比如浮点值\n12.8f,但 **Kotlin不支持8进制数值**\n\n* * *\n\n###  **存储原理**\n\njava平台上（Kotlin可以编译为javascript）,数字默认是采用java的原生类型，也就是说Int是按照int存储的。但如果我们要使用Int?（”?”表示可能为null，后续会讲解）或者泛型，则数字会自动装箱，也就是说Int按照Integer存储。\n\n需要注意的是数字装箱不会保证同一性，但会保留相等性，举个例子：\n\n    \n```   \n    val  a: Int = 10000 //原生类型存储\n    print(a === a) // 地址相同，打印 'true' \n    val boxedA: Int? = a //自动装箱\n    val anotherBoxedA: Int? = a //再次装箱\n    print(boxedA === anotherBoxedA) // 地址不同 打印 'false'--不保证同一性\n```\n\n再看以下代码\n\n    \n```   \n    val a: Int = 10000 //原生类型存储\n    print(a == a) // 内容相同\n    val boxedA: Int? = a//自动装箱\n    val anotherBoxedA: Int? = a//再次装箱\n    print(boxedA == anotherBoxedA) //内容相同// Prints 'true'--相等性\n```\n\n此处简单的说明一下”===”和”==” 的区别：\n\n  * “===”表示的是否引用地址相同 \n\n  * “==” 表示内容是否相同，等同于equals(),比较其值是否相等 \n\n* * *\n\n###  **类型转换**\n\n支持表达式形式的隐式转换比如：\n\n    \n```    \n     var a:Long =1L\n    var b:Int=1\n    var c=a+b //c是Long型的\n```\n\n但不支持\n\n    \n```   \n    var a:Long =1L\n    var b:Int=a  //编译报错\n```\n\n或者\n\n    \n```    \n    var b:Int=1\n    var a:Long =b //编译报错\n```\n\n但每个数字类型支持如下的转换，用于显式拓宽数字，需要转换的时候可以使用如下函数。\n\n  * ` toByte(): Byte `\n  * ` toShort(): Short `\n  * ` toInt(): Int `\n  * ` toLong(): Long `\n  * ` toFloat(): Float `\n  * ` toDouble(): Double `\n  * ` toChar(): Char `\n\n* * *\n\n##  **字符**\n\nKotlin中字符使用Char来表示，它们不能直接当做数字来处理（不同于java）。字符使用 ` '' ` 进行括起来，使用特殊字符可以使用转义字符 ` \\\n` ,支持这几个转义序列： ` \\t、 \\b、\\n、\\r、\\'、\\\"、\\\\ 和 \\$ ` 。\n\n* * *\n\n##  **布尔值**\n\nKotlin中使用Boolean来表示布尔值，它可以保存两种类型的值 ` true和false ` 。  \n支持的运算符如下：\n\n  * || – 短路逻辑或 \n  * && – 短路逻辑与 \n  * ! - 逻辑非 \n\n* * *\n\n##  **数组**\n\nKotlin中使用Array类来表示数组，它定义了 ` get ` 和 ` set ` 函数（按照运算符重载，内部仍然使用[]来访问）和size 属性。  \n下面我们介绍一下如何创建数组\n\n  * 使用 ` arrayOf ` 创建数组： ` var array: Array<String> = arrayOf(\"1\", \"b\") `\n\n  * 使用 ` arrayOfNulls ` 创建数组： ` var array3:Array<String?> = arrayOfNulls(5)//指定大小，并用null填充，此处声明使用String?,表示此处内容可能为null `\n\n  * 使用 ` Array ` 创建数组： ` val asc = Array(5, { i -> (i * i).toString() })// 前面的5是指定大小，后面的i是对应的索引0-4，{} 内的是初始化方法} `\n\nKotlin 也有无装箱开销的专门的类来表示原生类型数组: ByteArray、 ShortArray、IntArray 等等。这些类和 Array\n并没有继承关系，但是 它们有同样的方法属性集。它们也都有相应的工厂方法。\n\n* * *\n\n##  **字符串**\n\nKotlin中字符串使用String来表示，字符串是不可变的，可以使用s[i]的形式访问其中的字符，也可以遍历字符串，访问其中的字符。  \nKotlin中有两种字符串，转义字符串和 **原生字符串（不能使用转义字符）** ，下面介绍一下：\n\n  * 转义字符串：这种类似于java的字符串， ` val a:String=\"test word \\n\" `\n  * 原生字符串： \n``` \n         // 上下各三个 \"\"\" 引号包裹需要显示的内容\n    val a:String=\n            \"\"\"\n            白云黑土\n            宇宙洪荒\n            \"\"\"  //此种字符串会原样输出，保留此处的格式\n```\n* * *\n\n##  **字符串模板**\n\n字符串可以包含字符串模板，就是一小段代码，它的作用就是把求值的结果合并到字符串中，模板表达式使用$ 美元符号，下面举例说明：\n\n    \n```    \n     val a=10\n    val str=\"a的值是：$a\"//输出：a的内容是：10\n```\n还可以用于方法，比如：\n\n    \n```    \n    val a=\"test\"\n    val str=\"a的内容是：$a,长度是${a.length}\"  //输出:a的内容是：test,长度是4\n```\n字符串模板支持原生字符串和转义字符串。\n\n* * *\n\n##  **总结**\n\n至此已经学完了Kotlin的【基础类型】相关的知识，多回顾多思考，继续 [ 后续内容\n](http://blog.csdn.net/guohaiyang1992/article/details/72615889) 。\n\n","tags":["基础类型"],"categories":["Kotlin"]},{"title":"Java反射（一）","url":"%2Fpost%2F3a575bd1.html","content":"> 每天都要学习，坚持就是胜利\n\n本篇博客对反射进行简单介绍，用反射进行获取对象的成员变量和函数，并进行操作，这些是后续操作的基础\n\n---\n\n ***一、获取类的方法、构造方法、属性***\n\n 1.  获取Class对象\n   \n  - 方式一：`Class<?> class1 =Class.forName(\"com.guo.test.Person\")；`\n  - 方式二：`Class<?> class1=Person.class;`\n  - 方式三：`Person person=new Person();  Class<?> class1=person.getClass();`\n \n 2.  获取Class对象的属性 \n\n  ``` \nField[] allFields = class1.getDeclaredFields();//获取class对象的所有属性\nField[] publicFields = class1.getFields();//获取class对象的public属性\nField ageField = class1.getDeclaredField(\"age\");//获取class指定属性\nField desField = class1.getField(\"des\");//获取class指定的public属性\n   ```\n \n 3. 获取class对象的方法\n\n  ``` \nMethod[] methods = class1.getDeclaredMethods();//获取class对象的所有声明方法\nMethod[] allMethods = class1.getMethods();//获取class对象的所有public方法 包括父类的方法\nMethod method = class1.getMethod(\"info\", String.class);//返回次Class对象对应类的、带指定形参列表的public方法\nMethod declaredMethod = class1.getDeclaredMethod(\"info\", String.class);//返回次Class对象对应类的、带指定形参列表的方法\n  ```\n 4. 获取class对象的构造函数\n\n  ```\nConstructor<?>[] allConstructors = class1.getDeclaredConstructors();//获取class对象的所有声明构造函数\nConstructor<?>[] publicConstructors = class1.getConstructors();//获取class对象public构造函数\nConstructor<?> constructor = class1.getDeclaredConstructor(String.class);//获取指定声明构造函数\nConstructor publicConstructor = class1.getConstructor(String.class);//获取指定声明的public构造函数\n  ```\n 5. 其他方法\n\n  ```\nAnnotation[] annotations = (Annotation[]) class1.getAnnotations();//获取class对象的所有注解\nAnnotation annotation = (Annotation) class1.getAnnotation(Deprecated.class);//获取class对象指定注解\nType genericSuperclass = class1.getGenericSuperclass();//获取class对象的直接超类的 Type\nType[] interfaceTypes = class1.getGenericInterfaces();//获取class对象的所有接口的type集\n  ```\n\n---\n\n二、操作对象\n\n 1. 调用构造方法生成实例\n \n\n  ```\n//第一种方式 Class对象调用newInstance()方法生成\nObject obj = class1.newInstance();\n//第二种方式 对象获得对应的Constructor对象，再通过该Constructor对象的newInstance()方法生成\nConstructor<?> constructor = class1.getDeclaredConstructor(String.class);//获取指定声明构造函数\nobj = constructor.newInstance(\"hello\");\n  ```\n \n\n 2. 调用类的方法\n \n\n  ```\n// 生成新的对象：用newInstance()方法\n Object obj = class1.newInstance();\n//首先需要获得与该方法对应的Method对象\nMethod method = class1.getDeclaredMethod(\"setAge\", int.class);\n//调用指定的函数并传递参数\nmethod.invoke(obj, 28);\n  ```\n当通过Method的invoke()方法来调用对应的方法时，Java会要求程序必须有调用该方法的权限。如果程序确实需要调用某个对象的private方法，则可以先调用Method对象的如下方法。\nsetAccessible(boolean flag)：将Method对象的acessible设置为指定的布尔值。值为true，指示该Method在使用时应该取消Java语言的访问权限检查；值为false，则知识该Method在使用时要实施Java语言的访问权限检查。\n\n \n\n 3. 调用类的方法\n \n\n  ```\n//生成新的对象：用newInstance()方法 \nObject obj = class1.newInstance();\n//获取age成员变量\nField field = class1.getField(\"age\");\n//将obj对象的age的值设置为10\nfield.setInt(obj, 10);\n//获取obj对象的age的值\nfield.getInt(obj);\n  ```\n\n - 通过Class对象的getFields()方法或者getField()方法获得指定方法，返回Field数组或对象。\n\n - Field提供了两组方法来读取或设置成员变量的值：\n\n - getXXX(Object obj):获取obj对象的该成员变量的值。此处的XXX对应8种基本类型。如果该成员变量的类型是引用类型，则取消get后面的XXX。\n\n - setXXX(Object obj,XXX val)：将obj对象的该成员变量设置成val值。\n\n\n---\n\n先介绍这些，后续再详细介绍。","tags":["反射"],"categories":["java反射"]},{"title":"Pro android 之一  ：初步了解android","url":"%2Fpost%2F7666cf8a.html","content":"> 每日学习，不负年华\n\n* * *\n\n####  本篇博客主要是简要的介绍一下android 的基础知识，是之前写的博客了，整理一下。\n\n  1. 安卓平台的核心是linux内核，它负责设备驱动程序、资源访问、电源管理和完成其他操作系统的支持。 \n\n  2. 安卓支持两种类型的动画： ` 补间动画和逐帧动画 ` ；安卓通过 ` 动画回调、插值器和变形矩阵 ` 支持这两种动画方法 \n\n  3. 开发安卓程序至少需要理解 ` activity、view、intent、contentprovider、service 和androidMainfest.xml `\n\n  4. 四大组件简介： \n\n    * ` view: ` 看到的都是 ` view `\n    * ` activity： ` 表示应用程序的一个屏幕，可能包含0个至多个 ` view `\n    * ` intent: ` 执行某项操作 比如启动 ` activity contentprovider ` 共享数据 \n    * ` service: ` 可以长时间运行在后台的进程，分为本地service和远程service 本地service只能承载该service的应用程序访问，远程service则其他程序也可访问。 \n  5. ` AndroidMainfest.xml ` 定义了应用程序的内容和行为（用于Intent（意图）的过滤）和运行程序所需要的权限。 \n\n  6. xml 是一种臃肿的数据格式，我们在移动设备上使用xml时会使用AAPT（安卓资产打包工具），编译为二进制文件。所以可以在移动设备上使用xml而且不担心资源问题。 \n\n  7. 可见的activity会被系统提高优先级，当系统资源不足事系统会关闭优先级较低的应用，比如不可见的activity \n\n  8. activity的生命周期   \nonCreate() onStart() onRestart() onResume() onPause() onStop() onDestroy()\n\n  9. 刚创建activity的时候，安卓调用onCreate（）方法，然后总会调用onStart（）, 当activity在后台，但是没有被销毁，重新恢复可见的时候，就会调用onStart()，当一个activity将要跳到另一个activity的时候调用onPasue()，然后基本调用onStop()，此时activity不可见，如果想onPasue直接调用onresume,必须保证当前的activity是可见，且焦点没转移只要转移就会执行onStop,此时按back键就会回到onresume（），比如activity声明成dialog，其他的dialog不行actionbarActivity 不可，必须是activity才可以 \n\n  10. 常用的是onCreate()、onResume()、onPause() ；onPause()方法是系统结束应用程序前调用的最后一个安全的方法 \n\n","tags":["动画"],"categories":["Pro"]},{"title":"从零写一个线程切换工具","url":"%2Fpost%2Fc03edddb.html","content":"> 有的人在努力，有的人却在拼命，不负当下\n\n本篇博客主要是指引着写一个简单实用的线程切换工具，如果有更好的想法或者意见可以留言\n\n---\n\n###我们需要带着问题去学，看到题目不知道你是否有一下几个问题：\n\n - 如何切换线程\n - 如何通知下一个需要进行的任务\n - 如何去管理这些任务\n - 如何能更好的更直观的去看去使用\n\n---\n一、如何切换线程\n\n首先我们要知道如何进行基础的线程切换方法，如下：\n\n 1. 主线程\n 原理：比较通用的方法是获取主线程的`handler`,然后使用`post（runnable r）`方法，从写 `run()`方法，`run（）`方法内的代码就是在主线程内运行，即使你运行这段代码在其他线程。\n \n 代码：\n \n\n  ```java\n  //初始化基础数据\nLooper looper=Looper.getMainLooper();  //构造主线程handler关键\nHandler handler=new Handler(looper); //将主线程的looper放入\n//运行在主线程的方法\npublic static void runInUiThread(Runnable r) {\n        if (handler != null) {\n            handler.post(r);\n        }\n    }\n  ```\n\n 2. 子线程\n 原理：正常情况下可以直接new Thread,然后调用start()方法，此处考虑到线程的重用，采用线程池。\n \n 代码：\n \n\n  ```java\n  //初始化基础数据\nprivate static ExecutorService mCacheExcutor = Executors.newCachedThreadPool();//初始化线程池，用于切换到线程\n//运行在子线程的方法\npublic static void runInBackGroundThread(Runnable r) {\n        if (mCacheExcutor != null) {\n            mCacheExcutor.execute(r);\n        }\n    }\n  ```\n通过如上的步奏就已经知道如何将线程切换至主线程和子线程了，下面我们将如何将任务联系起来。\n\n---\n\n二、如何通知下一个任务？\n我们要做的不能是没有什么用途的工具，所以在此我们考虑一下什么时候需要进行线程切换？举个例子，如果你需要从数据库或者网络获取数据，然后刷新ui,这时候你可以采用原始的线程方式，然后内部多次嵌套,代码如下：\n\n \n\n 1.  嵌套执行\n\n  ```\n handler.post(new Runnable() {\n            @Override\n            public void run() {\n            //显示进度条\n                new Thread() {\n                    @Override\n                    public void run() {\n                        super.run();\n                        //下载或者获取内容\n                        handler.post(new Runnable() {\n                            @Override\n                            public void run() {\n                            //关闭进度条\n                            }\n                        });\n                    }\n                }.start();\n            }\n        });\n  ```\n看到这样的代码只有绝望。。。估计没有多少人愿意读，更不会想修改，当然我们也可以用google给封装好的,其代码如下：\n\n \n\n 1. AsyncTask方式\n \n  ```\nclass DownloadTask extends AsyncTask<Void, Integer, Boolean> {  \n  \n    @Override  \n    protected void onPreExecute() {  \n        //主线程\n    }  \n  \n    @Override  \n    protected Boolean doInBackground(Void... params) {  \n      //子线程\n    }  \n  \n    @Override  \n    protected void onProgressUpdate(Integer... values) {  \n        //主线程\n    }  \n  \n    @Override  \n    protected void onPostExecute(Boolean result) {  \n      //主线程 \n    }  \n}  \n  ```\n\n - 这个看起来确实挺直观的，代码逻辑也简单了不少，可是如果需要多次切换呢，比如：主线程->子线程->主线程->子线程。。。这时候AsyncTask 就无法胜任了，当然目前还有个更加优秀的开源库，本库的思想也借鉴于此，这个库更加酷炫（Rxjava）,有兴趣的可以看一下，我们开讲我们的库能干什么。\n我们来完成这个主线程->子线程->主线程->子线程变态任务，如果我们的库去写如何实现呢？代码如下：\n 3. 当前库的写法\n\n   ```java\n\n  TaskManager.getNewInstance().addTask(new Task() {\n            @Override\n            public void runInTask() {\n            //主线程\n            }\n        }).addTask(new Task(true) {\n            @Override\n            public void runInTask() {\n            //子线程\n            }\n        }).addTask(new Task() {\n            @Override\n            public void runInTask() {\n            //主线程\n            }\n        }).addTask(new Task(true) {\n            @Override\n            public void runInTask() {\n            //子线程\n            }\n        }).start();\n   ```\n\n - 现在我们开始解剖Task 的设计，代码如下：\n\n```java\npublic abstract class Task implements Runnable {\n    //下一个任务\n    private Task afterTask;\n    //标志为是否在线程中执行\n    private boolean isBackGround = false;\n    /**\n     * 构造函数\n     *\n     * @param isBackGround 标志：是不是子线程执行\n     */\n    public Task(boolean isBackGround) {\n        this.isBackGround = isBackGround;\n    }\n\n    /**\n     * 默认是ui线程\n     */\n    public Task() {\n        this.isBackGround = false;\n    }\n\n    public Task getAfterTask() {\n        return afterTask;\n    }\n\n    public boolean isBackGround() {\n        return isBackGround;\n    }\n\n    @Override\n    public void run() {\n        if (isBackGround) {\n            ThreadUtils.runInBackGroundThread(new Runnable() {\n                @Override\n                public void run() {\n                    runInTask();\n                    runAfterTask();\n                }\n            });\n\n        } else {\n            ThreadUtils.runInUiThread(new Runnable() {\n                @Override\n                public void run() {\n                    runInTask();\n                    runAfterTask();\n                }\n            });\n        }\n    }\n\n    protected void runAfterTask() {\n        if (afterTask != null) {\n            afterTask.run();\n        }\n    }\n\n    public abstract void runInTask();\n\n    /**\n     * 添加下一个task\n     *\n     * @param task 需要添加的task\n     * @return 返回当前添加的task用于下次添加\n     */\n    public Task addNextTask(Task task) {\n        setAfterTask(task);\n        return task;\n    }\n\n    private void setAfterTask(Task afterTask) {\n        this.afterTask = afterTask;\n    }\n}\n```\n\n主要方法在run(）方法内，根据自身的线程状态位来判断当前需要在什么环境下执行，然后回调runInTask（）,也就是暴露到外部的方法，然后执行下一个任务的run（）方法，这样就完成了任务之间的关联，而且通过刚才讲过的线程工具方法，进行线程的切换。\n\n三、如何取管理这些任务？\n\n \n\n 1. 从上面使用的时候的代码，通过TaskManager进行任务的添加并且使用start()方法开启任务。\nTaskManager代码如下：\n 2. TaskManager代码\n```\npublic class TaskManager {\n\n    //第一个任务\n    private Task firstTask = null;\n    //上一个任务\n    private Task lastTask = null;\n\n    private TaskManager() {\n\n    }\n\n    public static TaskManager getNewInstance() {\n        return new TaskManager();\n    }\n\n    public void clearTask() {\n        firstTask = null;\n        lastTask = null;\n    }\n\n    public TaskManager addTask(Task task) {\n        if (firstTask == null) {\n            lastTask = firstTask = task;\n        } else {\n            lastTask.addNextTask(task);\n            lastTask = task;\n        }\n\n        return this;\n    }\n\n    public void start() {\n\n        if (firstTask != null) {\n            firstTask.run();\n        } else {\n            throw new NullPointerException(\"任务不能为空！\");\n        }\n\n    }\n\n\n}\n```\n主要是两个关键的地方，一个是记录第一个，用于开启整个任务，另一个是记录上一个，用于添加下一个任务\n\n四、如何让逻辑更加简练？\n\n我们的库采用的是链式调用，既保证了线程的切换，也保证了逻辑的连贯性，逻辑更容易理解和易懂。\n\n[源码 csdn](http://download.csdn.net/detail/guohaiyang1992/9824255)   ,  [源码 github](https://github.com/guohaiyang1992/ThreadUtils/)\n\n","tags":["链式"],"categories":["Android"]},{"title":"对象和对象引用","url":"%2Fpost%2F9dea1882.html","content":"> 每天都在变化，每天都在进步\n\n###本篇博客从例子出发讲解对象和对象引用的关系\n\n   ---\n\n 1. 基础情况\n ```java\n \n A a=new A();\n\n A a; //创建了个A 类型的引用a，此时指向null\n\n new A(); //在堆中创建了一个类A的对象，返回其引用地址\n\n = //将对象的地址给予引用\n\n ```\n  ---\n\n 2. 情景1\n\n  ```\n  A a=new A(); //（01）\n  A b=a;//（02）\n  a=null；//（03）\n  ```\n\n  此时b仍然有数据，因为（02）的时候，发生了复制行为，引用发生了复制，也就是此时a,b 同时指向了（01）的时候创建的对象，此时即使执行了（03），原有的内容仍在，b的引用仍然在。\n\n    ---\n\n 3. 情景2\n\n  ```\n  public void test(A test){\n  test=new A();\n  }\n\n  A a=new A();//(01)\n  test(a); //(02)\n \n  ```\n\n 结论： （01）步骤的a引用仍是原来的，并没因为(02 )发生变化，因为方法传参的时候也发生了引用的复制，所以此时（02），对第二个test引用进行了修改并不影响（01）的内容\n\n    ---\n\n 4. 情景3\n\n ```\n public void test(A test){\n test.setB(\"dd\");\n }\n\n A a=new A();//(01)\n test(a); //(02)\n\n ```\n\n 结论：此时a的引用对象内容改变，因为引用和复制后的引用都指向相同的对象，此时会发生变化\n\n    ---\n\n 5. 情景4\n\n 对于List、Map 是等同的\n\n ```\n A a=new A();\n List<A> test=new ArrayList<>();\n test.add(a);\n a=null;  \n ```\n\n 结论：这个情况和情景2类似，发生了方法传参\n\n\n总结：对于对象引用来说  \"=\" 和传参会导致引用复制，此时就相当于多个引用对应于一个对象，此时其中的一个引用更换引用或者设置为null并不会影响其他的引用，如果修改了对象，则对于所有引用，其内容都是一致的。","tags":["对象引用"],"categories":["android技巧"]},{"title":"三、复合类型","url":"%2Fpost%2F9215f121.html","content":"> 日积月累，日新月异\n\n**_本篇主要介绍c++中有关数组和字符串相关知识。_ **\n\n  1. 数组声明（与java的一致） ` type arrayName[size]; `\n\n  2. 数组数据的获取和java相同使用 arrayName[对应下标，从0开始]，同样的编译器无法告知你是否超出数组的范围，java中超出范围会抛出index of exception 数组越界异常，c++则不一定，c++中属于按地址取值，如果对应位置有数据则显示数据，反之则可能报错。 \n\n  3. c+中允许以下声明 ` int a[3]; ` **_java中不允许_ ** ，因为此时未给其申请内存，属于不可用。 c++中此时可以通过 a[0]~a[2] 进行赋值，如果进行初始化操作也是不允许的。比如： ` int a[3]; a[3]={1，2，3} ` ； \n\n  4. c++ 中数组初始化规则：只有在定义数组的时候才可以使用初始化，此后不允许使用，也不能将数组赋值给另一个数组。（c++中对于地址有专门的描述方式比如指针，有关地址的处理上就可能不一样） \n  ```  \n        int  a[4]={3,6,8,9};   //c++ 允许，java不允许\n    int a[]={3,6,7,8};   // c++ 允许 java 允许\n    int a[4];           //c++ 允许 java不允许\n    a[4]={1,2,3,4};     //c++和java都不允许 \n    int a[]={3,6,7,8}; \n    int b[];  b=a;      // c++不允许 java允许\n```\n数组的操作在java 中和对象的是一致的，” = ” 是将引用copy， b=a\n相当于b,a指向同一个数组或者对象。C++中对象的操作类似java，原理还带深入，不过表现是一致的，但是数组操作是不一样的。数组地址采用的是常量指针，所以不允许重新赋值，换言之如果采用的不是常量指针就是可以的，究竟处于什么考虑这样设置，还需深究\n\n举例，c++ 对象行为是允许的\n\n  ```  \n        A a,b;\n    a=new A();\n    b=a;\n```\n\n  5. 声明字符串可以采用 ` char fish[]=\" ddff\"； ` 字符串的存储上最后一位是空字符，用于标识字符串结束 \n\n  6. 使用string的时候需要导入同文件 ` cstring或者string.h ` （c语言风格） \n\n  7. strlen 计算可见字符的长度 sizeof(arrayName) 数组的长度，字符串输出到出现空字符的时候停止，即使此时有其他的字符 \n\n  8. 要使用string类的时候必须包含头文件string 注意是小写，还需要使用命名空间 \n    \n        using namespace std; //（c++风格）\n\n  9. c++字符串的声明是小写的string,java中是大写，而且c++中字符串可以当做数组处理   \n例子：\n\n    \n        string str1=\"test\";\n    cout<<str1[0];   //结果为t\n\n  10. 不能将数组赋值给另一个数组但是可以将string对象赋值给另一个string对象 \n\n  11. string简化了字符串合并操作，可使用+或者+=等同于java中的用法 \n\n  12. 对于c语言风格如果想copy字符串可以使用 \n ```   \n        strcpy(char1,char2); //copy char2 to char1\n    strcat(char1,char2);//append char2 to char1\n```\n* * *\n\n###  相关资料： [ 汇总地址\n](http://blog.csdn.net/guohaiyang1992/article/details/62589298)\n\n* * *\n\n","tags":["c语言"],"categories":["Android"]},{"title":"有关对象地址和对象关系的认识","url":"%2Fpost%2Fe00718d5.html","content":"> 善于把握细节，或许有新发现\n\n###  对象的地址和对象的解释\n\n  * 举例 ： 类 A 对象a \n  * 操作： ` A a=new A(); `\n  * 解释：   \n\n    * ` a ` 存储的是 ` A ` 类型的对象引用。 \n    * ` a ` 存储在栈中，保存的是对应新创建出对象的地址（堆中的地址）。 \n    * ` new A() ` 创建的对象保存在堆中 。 \n    * 通过 ` a ` 可以操作原对象，操作原对象的成员函数和成员变量，这样是修改的原数据 。 \n    * 如果重复上面的步骤：   \n` a=new A(); `  \n此时新的地址赋予a，a存储的地址就是新的，之前的对象还在，但是无法获取到了，在c++ 中就是属于野指针，因为使用完成并没有释放内存，  \n在java中有gc管理内存，所以这个没有被引用的资源会在内存不足的时候销毁掉，所以java中可以加强对对象的重用或者不用的时候及时取消引用，  \n这样会尽快的释放内存，减少内存无谓的占用。\n\n","tags":["内存"],"categories":["android技巧"]},{"title":"Android实现Edittext显示下滑线的三种方法","url":"%2Fpost%2Fc6da4763.html","content":"> 付出终有回报，找准方向，努力向前\n\n####  一、简介\n本文章主要介绍三种方式实现Edittext下方显示下滑线，各有利弊，可以根据情景自行选择，其中有关字体显示的基准线、行高相关的知识。此篇主要介绍正常模式下代码如何去写，这里还有一篇是兼容行距（设置倍数或者具体数值）。\n\n\n----------\n\n\n#### 二、可收获\n\n 1. 如何实现Edittext显示下划线\n\n 2.  根据情况如何选择实现方式\n\n 3. 字体的行高、基准线是什么 \n\n\n----------\n\n\n#### 三、如何实现\n\n ***1）最简单的方式***\n - 基本原理：Edittext可以直接获取它绘制时的Paint，并设置下划线属性即可。\n -  基本操作：代码如下\n \n\n```java\n EditText editText= (EditText) findViewById(R.id.test_et);\n editText.getPaint().setFlags(Paint.UNDERLINE_TEXT_FLAG);//设置下滑线属性\n```\n- 结论：该方法实现简单，兼容性强，兼容各种字体边距等情况，但是只能实现输入多少行显示多少行，不能自定义显示行数。\n\n\n----------\n\n\n***2）自定义View的形式*** \n\n - 基本原理：通过重写onDraw方法，自己测算出线的位置，自己绘制下滑线。\n - 基本操作：\n\n```\n        //获取参数\n        int padL = this.getPaddingLeft();//获取框内左边留白\n        int padR = this.getPaddingRight();//获取框内右边留白\n        int padT = this.getPaddingTop();//获取框内顶部留白\n        int lines = this.getLineCount();//获取行数\n        float size = this.getTextSize();//获取字体大小\n        float baseTop = padT + size/6;//神秘数字\n        float gap = this.getLineHeight();//行距\n        mPath.reset();\n        //从上向下划线\n        for (int i = 1; i <= Math.max(lines, maxNoteLines); i++) {\n            mPath.moveTo(padL, baseTop + gap * i);\n            mPath.lineTo(this.getWidth() - padR, baseTop + gap * i);\n        }\n        canvas.drawPath(mPath, mPaint);\n```\n\n - 原理解析：其中`getLineCount()`是获取当前的行数，`getTextSize()`是获取字体的大小，核心计算就是计算线的y坐标，`baseTop + gap * i`，这个是此处的计算方法，而正常情况下   ，`padT+gap*i`  应该就是线的位置，但是事实是，线总在字上，所以翻看了`getLineHeight()`,它是计算行高的，但是官方文档说会比正常的行高或低或高，但是我后面测试了一下，绘制的文字确实是按照此高度划分行的，也就是每行的行距就是这个值。\n -  为了弥补高度的不足，`padT+size/6`正好满足了显示，且兼容各种字体和大小。一般情况下都会对这个数据`size/6`比较疑惑，这个值是恰好测算出来的，并没什么依据。这个研究了许久也没啥进展，然后以此演变出有些许理论依据的第二版本，如果此处有什么高见可以下方留言，谢谢。\n - 结论： 此方法兼容性也可以，也兼容显示多行线，采用的path,可以设置为虚线、实线。\n\n----------\n\n\n***3）有理有据的自定义View的形式*** \n\n - 基本原理：通过重写onDraw方法，自己测算出线的位置（测算方法不同），自己绘制下滑线。\n - 基本操作：\n\n```\n        //获取参数\n        int padL = this.getPaddingLeft();//获取框内左边留白\n        int padR = this.getPaddingRight();//获取框内右边留白\n        int padT = this.getPaddingTop();//获取框内顶部留白\n        int lines = this.getLineCount();//获取行数\n        float size = this.getTextSize();//获取字体大小\n        float baseTop = padT + size/6;//神秘数字\n        float gap = this.getLineHeight();//行距\n        mPath.reset();\n        //从上向下划线\n        for (int i = 0; i <= Math.max(lines, maxNoteLines); i++) {                mPath.moveTo(padL,getBaseline()+getPaint().getFontMetrics().descent+gap*i);\n        \nmPath.lineTo(this.getWidth() -padR,baseLineY+gap*i+getPaint().getFontMetrics().descent);\n        }\n        canvas.drawPath(mPath, mPaint);\n```\n\n - 原理解析：核心代码`getBaseline()+getPaint().getFontMetrics().descent+gap*i`，此处理解需要一定的基础，看下图：\n \n - ![文字绘制原理图](http://img.blog.csdn.net/20141124164740174?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWlnZXN0dWRpbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n我们如果想绘制线的话，首先需要知道第一个线的位置，然后剩余的线间隔是gap，我们从途中可以知道，线的位置=baseLine+descent,所以公式：`getBaseline()+getPaint().getFontMetrics().descent+gap*i`\n\n - 结论： 此方法兼容性也可以，也兼容显示多行线，采用的path,可以设置为虚线、实线。\n\n#### 四、结论\n这篇文章写的也算比较仓促，有些地方感觉自己也想的还不够透彻。如果有疑问、更好的建议、或者纠正欢迎留言。demo下载地址：[代码地址](http://download.csdn.net/download/guohaiyang1992/9787744)","tags":["font"],"categories":["Android"]},{"title":"二、C++处理数据","url":"%2Fpost%2F6afb4c24.html","content":"> 千里之行，始于足下\n\n**_本篇主要介绍c++中有关的基础数据类型的声明和使用以及基本的操作符相关知识。_ **\n\n  1. 计算机内存的基本单位是位（bit），1字节（byte）等于8位 \n\n  2. sizeof 返回类型的长度，单位是字节 \n\n  3. define 是预处理命令，举例：#define INT_MAX 32767 告诉预处理器在程序中查找INT_MAX都使用32767来代替 \n\n  4. 创建符号常量使用关键词const \n\n  5. 变量赋值的特殊形式 \n\n    * int wir(32); 将32赋值给wir \n    * int wir{32}; 将32赋值给wir \n    * int wir={32}; 将32赋值给wir \n    * int wir={}; 将0赋值给wir \n  6. 如果想使用无符号数需要在声明处加上关键词 unsigned \n\n    * 举例：unsigned int test; \n  7. c++中使用前一（两）位来标识数字字面量的基数；（等同于java的方式） \n\n    * 十进制：第一位是1~9 \n    * 八进制：第一位是0 \n    * 十六进制：前两位 0x \n  8. 数值后加入字母用于表示类型 ，举例 16uL ，表示16是long型(L)，且无符号（u）,java 没有无符号的表示方法，其他的一致。 \n\n  9. 字面值true 和false都可以通过提升转换为int类型，true被护照那换为1，false被转换为0 \n\n    * int ans=true; 表示将1赋值给ans \n    * int pro=false; 将0赋值给pro \n  10. 任何数字值或者指针值都可以被隐式转换为bool类型，任何非零值转换为true,而零转换为false \n\n  11. c++中定义常量使用const关键词，定义后编译器不允许再次修改该变量的值。这种效果等同于java中的final，定义后也不许再次修改，java中的const关键词被保留但未使用。 \n\n  12. 除法运算符（/）的行为取决于操作数的类型。如果操作数都是整数，则结果的小数部分将被丢弃，如果操作数中有一个是浮点数，则结果是浮点数。规则和java相同 \n\n  13. 类型转换并不会影响原有的数据，而是创建新的数据赋值给对应的变量 \n\n  14. c++中可以使用auto进行声明，其变量类型根据赋值确定 \n\n    * auto n=100； n是int \n\n* * *\n\n###  相关资料： [ 汇总地址\n](http://blog.csdn.net/guohaiyang1992/article/details/62589298)\n\n* * *\n\n","tags":["const"],"categories":["Android"]},{"title":"一、开始学习c++","url":"%2Fpost%2Fdc6e7317.html","content":" \n\n 1. 预处理器编译指令#include,源代码添加之前，添加或替换文本\n \n 2. 编译指令 using namespace \n\n 3. 使用cin cout 进行输入和输出的程序必须包含头文件 iostream\n\n 4. c++中使用声明指出需要存储的位置和内存空间（例如  int a,指出需要的内存以及该内存单元的名称），c++ 中所有变量都需要声明\n\n 5. c++程序应当为每一个使用的函数提供原型，像变量声明和变量的关系. c++ 和java的不同点是，如果你调用的方法，在你之前没有声明，则不能使用。如果在你之前的位置，声明和定义可以写到一起。\n\n```\n//声明在前，实现在后（情况1）\nint deletes(int,int);\n\nint main(int argc, const char * argv[]) {\n    cout<<\"测试结果\";\n    cout<<add(3, 4)<<endl;\n    int a=3;\n    cout<<a<<endl;\n    cout<<deletes(3, 1)<<endl;\n    return 0;\n}\nint deletes(int a,int b){\n    return a-b;\n}\n```\n\n```\n//声明和定义在一起，此时对方法顺序有要求（情况2）\nint deletes(int a,int b){\n    return a-b;\n}\n\nint main(int argc, const char * argv[]) {\n    cout<<\"测试结果\";\n    cout<<add(3, 4)<<endl;\n    int a=3;\n    cout<<a<<endl;\n    cout<<deletes(3, 1)<<endl;\n    return 0;\n}\n```\n\n---\n###相关资料：[汇总地址](http://blog.csdn.net/guohaiyang1992/article/details/62589298)\n---","tags":["iostream"],"categories":["Android"]},{"title":"c++ 知识汇总","url":"%2Fpost%2Fec9ccc1f.html","content":"####  c++ 相关知识的记录,后面持续更新。\n\n_本系列博客适用于有一定编程基础的人员进行学习，尤其是java基础然后学习C++，其中主要说明的大都是两种语言的不同之处。_\n\n  1. [ 开始学习C++ ](http://blog.csdn.net/guohaiyang1992/article/details/62591635)\n\n  2. [ 处理数据 ](http://blog.csdn.net/guohaiyang1992/article/details/63871987)\n\n  3. [ 复合类型 ](http://blog.csdn.net/guohaiyang1992/article/details/70234253)\n\n","tags":["c++"],"categories":["Android"]},{"title":"Android播放Gif图片","url":"%2Fpost%2Fd3d34deb.html","content":">每次的探索都源于好奇，每次的收获都是坚持的结果。\n###一、简介\n本文章介绍三种主流的方法去播放gif图片，并介绍优劣势方便今后使用的时候更快更容易的找到自己需要使用的播放gif的方法，后续可能有对应原理的解析，此篇只用于介绍使用。\n### 二、可收获\n\n 1. 了解三种gif的播放方式，以及如何使用\n 2.  知道三种gif播放的优劣势\n 3. 了解如何从网络下载gif，知道一些rxjava和retrofit的知识。\n\n###三、android播放gif的方法\n\n#### 1）使用Movie播放Gif\n\n - 基本原理：使用Movie类，将图片加载到Movie内，通过不断的绘制，不断的切换时间，达到播放Gif的目的。\n - 基本操作：\n -- 首先自定义一个GifView用于使用Movie和接收Gif图片。（使用前先在对应位置放好Gif文件）\n --代码如下\n \n\n```\npublic class GifView extends View {\n\n    private Movie mMovie;\n    private long mMovieStart = 0;\n\n    public GifView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n    }\n\n    public void startGif(String path)  {\n    //此方法用于加载drawable内的gif图片\n//        mMovie = Movie.decodeStream(getResources().openRawResource(R.drawable.test));\n        byte[] array = new byte[0];\n        try {\n        //用于加载本地文件gif图片\n            array = streamToBytes(new FileInputStream(path));\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n        mMovie = Movie.decodeByteArray(array, 0, array.length);\n        invalidate();\n    }\n\n    //关键代码，原理已经说过\n    @Override\n    public void onDraw(Canvas canvas) {\n\n        long now = android.os.SystemClock.uptimeMillis();\n\n        if (mMovieStart == 0) {\n            mMovieStart = now;\n        }\n\n        if (mMovie != null) {\n            int dur = mMovie.duration();\n\n            if (dur == 0) {\n                dur = 1000;\n            }\n\n            int relTime = (int) ((now - mMovieStart) % dur);\n            mMovie.setTime(relTime);\n            mMovie.draw(canvas, 0, 0);\n\n            invalidate();\n        }\n    }\n\n\n    private static byte[] streamToBytes(InputStream is) {\n        ByteArrayOutputStream os = new ByteArrayOutputStream(1024);\n        byte[] buffer = new byte[1024];\n        int len;\n        try {\n            while ((len = is.read(buffer)) >= 0) {\n                os.write(buffer, 0, len);\n            }\n        } catch (java.io.IOException e) {\n        }\n        return os.toByteArray();\n    }\n}  \n```\n\n - 结论：此方法我测试过，速度很慢，此方法也可以控制gif的播放，可以通过是否重绘进行控制，或者可以使用**ValueAnimator** ，根据对应的Gif时长生成对应长度的value，实时根据value设置time，用于控制播放暂停等操作，但根本原因加载太慢**不推荐使用**。\n \n #### 2）使用glide加载gif\n \n - 基本原理：glide内部会识别你是用的是什么类型的图片，如果是gif图片，内部会转变为GifDrawable用于播放。\n - 代码：\n -首先配置build.gradle\n -`  compile 'com.github.bumptech.glide:glide:3.7.0'`\n -配置仓库\n\n```\n buildscript {\n     repositories {\n        jcenter()\n        mavenCentral()\n    }\nallprojects {\n    repositories {\n        jcenter()\n        mavenCentral()\n    }\n}\n```\n-使用：\n\n```java\n   ImageView imageView = (ImageView) findViewById(R.id.test_img);\n   //load方法内可以传入资源id也可以传入下载链接\n   Glide.with(this).load(GifUtils.localPath).into(imageView);\n```\n\n\n\n - 结论：该方法首次加载也比较慢，但Glide内有缓存，无需考虑数据的来源（本地或者网络），不需要考虑数据的缓存。刚开始以为加载速度慢是因为下载的问题，后面加载本地的速度依然很慢，具体原因后面探索，初步怀疑是java解析的速度慢。**想轻松一点的话可以使用此方法，如果追求速度，请看下面的**。\n\n#### 3）使用android-gif-drawable\n\n- 基本原理：内部转化为gifdrawable,类似于使用动画一样进行播放，内部使用c++的方法逐帧播放。内部原理还需探究。\n\n-代码如下：\n\n-非下载的使用方式：\n\n```\nGifImageView gifImageView= (GifImageView) findViewById(R.id.test_img);\ngifImageView.setImageDrawable(new GifDrawable(new File(GifUtils.localPath)));\n```\n\n-下载的方式：\n首先定义下载：\n\n```\npublic interface ServiceApi {\n      \n    //下载文件  \n    @GET\n    Observable<ResponseBody> downloadPicFromNet(@Url String fileUrl);\n  \n}  \n```\n\n其次定义下载和显示：\n\n```\npublic class DownloadPicUtils {\n   public static void getPicFromNet(final GifImageView gifImageView) {\n\n        Retrofit retrofit = new Retrofit.Builder()\n                .baseUrl(\"http://www.baidu.com/\")//此处是无效基地址，但是不能写空字符串\n                .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) //添加Rxjava\n                .addConverterFactory(GsonConverterFactory.create()) // 默认添加后返回gson格式，但是首先他会根据你返回的类型去判断默认的是否可以，默认的就是返回responseBody，如果满足不执行其他的，反之继续遍历转换器，找到符合的\n                .build();\n\n        ServiceApi serviceApi = retrofit.create(ServiceApi.class);\n\n        serviceApi.downloadPicFromNet(GifUtils.netPath)\n                .subscribeOn(Schedulers.newThread())//在新线程中实现该方法\n                .map(new Func1<ResponseBody, String>() {\n\n                    @Override\n                    public String call(ResponseBody arg0) {\n                        return saveImgFromNet(arg0);\n                    }\n                })\n                .observeOn(AndroidSchedulers.mainThread())//在Android主线程中展示\n                .subscribe(new Subscriber<String>() {\n\n\n                    @Override\n                    public void onStart() {\n                        super.onStart();\n                    }\n\n                    @Override\n                    public void onCompleted() {\n                    }\n\n                    @Override\n                    public void onError(Throwable arg0) {\n                        Log.v(\"info\", \"error:\" + arg0.toString());\n                    }\n\n                    @Override\n                    public void onNext(String arg0) {\n\n                        try {\n                            gifImageView.setImageDrawable(new GifDrawable(new File(GifUtils.localPath)));\n                        } catch (IOException e) {\n                            e.printStackTrace();\n                        }\n\n                    }\n                });\n    }\n\n    private static String saveImgFromNet(ResponseBody arg0)  {\n        try {\n            FileHelper.saveBytesToFile(arg0.bytes(), GifUtils.localPath);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return GifUtils.localPath;\n    }\n}\n```\n文件存储辅助类：\n\n```\npublic class FileHelper {\n\n    public static byte[] getBytesFromStream(InputStream is) throws IOException {\n\n        int len;\n        int size = 1024;\n        byte[] buf;\n\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        buf = new byte[size];\n        while ((len = is.read(buf, 0, size)) != -1) {\n            bos.write(buf, 0, len);\n        }\n        buf = bos.toByteArray();\n\n        return buf;\n    }\n\n\n    public static void saveBytesToFile(byte[] bytes, String path) throws IOException {\n        FileOutputStream fileOuputStream = null;\n        try {\n            fileOuputStream = new FileOutputStream(path);\n            fileOuputStream.write(bytes);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (fileOuputStream != null) {\n                fileOuputStream.close();\n            }\n        }\n    }\n}\n```\n\n使用方式：\n\n```java\n GifImageView gifImageView= (GifImageView) findViewById(R.id.test_img);\n DownloadPicUtils.getPicFromNet(gifImageView);\n```\n\n - 此方法加载gif速度很快，即使加上下载的速度仍比其他的两种快，就是内部没有缓存和网络模块，需要自己去实现，不过如果追求性能，这个是属于**最推荐**的方式","tags":["Android 技术笔记"],"categories":["Android"]},{"title":"适配器模式","url":"%2Fpost%2Ff5c535ea.html","content":"1.适配器模式的定义：将一个类的接口转换成客户希望的另一个接口。适配器模式使得原本由于接口不兼容而不能工作在一起的的类可以一起工作\n\n  \n\n2.功能：主要功能是进行转换匹配，目的复用已有的功能，而不是重新实现接口；对象组合，适配器的实现方式其实是依靠对象组合的方式，通过给适配器对象组合被适配的对象，当客户端调用target的时候，适配器会把对应的功能委托给被适配的接口完成\n\n  \n\n3.适配器的实现：\n\n1）实现适配器的时候，它通常是一个类，一般会让适配器实现target 接口，然后具体实现中调用被适配的类，也就是说适配器通常是Target 类型\n\n2）智能适配：适配器可以实现一些被适配接口没实现的功能，但在Target 中定义的功能\n\n  \n\n4.适配器的类型： 对象适配器和类适配器\n\n1） 对象适配器：依赖于对象的组合\n\n2）类适配器：采用多重继承对一个接口与另一个接口进行匹配\n\n  \n\n5.适配器的优点：\n\n1） 更好的复用性，功能已经有啦，只是接口不兼容，那么通过适配器模式就可以让功能得到更好的复用\n\n2）更好的拓展性，可以调用自己开发的功能，从而自然的拓展系统功能，。\n\n  \n\n6.适配器模式缺点：\n\n1）过多的使用适配器，会让系统非常凌乱，不容易整体进行把握，如果不是很有必要，可以不使用适配器，而是直接对系统进程重构\n\n  \n\n7.适配器本质：转换匹配，复用功能----适配器通过转换已有的实现，从而把已有的实现匹配成需要的接口，使之能满足客户端的需要\n\n  \n\n8.何时使用适配器模式：\n\n1）如果想使用一个已经存在的类，但是接口不符合你的需求，这种情况下使用适配器模式，吧已有的实现转换为你需要的接口\n\n2）创建一个可以复用的类，课可以和一些不兼容的类一起工作这种情况可以使用。\n\n3）已经存在对应的子类，可以使用对象适配器\n\n  \n\n9.相关模式：\n\n1）适配器与桥接模式：适配器模式是把两个或者多个接口的功能进行转换，二桥接模式是让接口和实现部分分离，以便他们可以独立的变化。\n\n  \n\n","tags":["适配器模式"],"categories":["设计模式"]},{"title":"外观模式","url":"%2Fpost%2Ff7de8aa8.html","content":"1.外观模式的定义：为子系统的一组接口提供一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。（遥控器？）\n\n  \n\n2.界面： 主要指的是从一个组件的外部看这个组件，能看到什么，界面或者外观。 （类中的public 方法，模块的外部接口）\n\n  \n\n3.接口：内部外部沟通的通道，通常是指的方法，可以是类的方法，可以是interface 的方法\n\n  \n\n4.应用外观模式来解决问题的思路：客户端需要简单的操作，所以根据客户端定义简单的接口，然后让客户调用这个简单的接口，剩下的事就不需要管了。\n\n  \n\n5.外观模式就是通过引入这么一个外观类，在；类中定义客户端想要的简单的方法，然后在方法中实现，由外观类调用内部模块来实现。这样客户端只需要和外观类交互即可，外观类也可以说是接口类（接口指的是通信的方法。）\n\n  \n\n6.facade: 定义子系统的多个模块对外的高层接口，通常需要调用内部调用的多个模块，从而把客户的请求代理给合适的子系统对象\n\n模块：接受facade对象的委派，真正实现功能，各个模块之间可能有\n\n  \n\n7.外观模式的目的：外观模式的目的不是给子系统添加新的功能接口，而是为了让外部减少与子系统内多个模块的交互，松散耦合，从而让外部能够更简单的使用子系统。\n外观应该是包装已有的功能，主要是负责组合已有功能来实现客户需要，而不是添加新的变化。\n\n  \n\n8.外观模式只是显示一个功能的组合调用\n\n  \n\n9.外观模式的优点： 外观模式松散了客户端与子系统的耦合关系，让子系统内部的模块更容易拓展和维护；简单易用\n：外观模式让子系统更加易用，客户端不再需要了解子系统内部的实现，也不需要跟众多的子系统内部的模块进行交互，只需要跟外观交互即可，相当于外观类为外部客户端使用子系统提供了一站式服务\n\n  \n\n10.外观模式的缺点：过多或者不太合理的facade 容易使人迷惑。\n\n  \n\n11.外观模式本质： 封装交互，简化调用\n\n  \n\n12.何时使用外观模式：\n当你希望为一个复杂的子系统提供一个简单接口，可以使用外观模式；如果想让客户程序和抽象类实现部分，让客户端和子系统分离，提高子系统的独立性和可移植性\n\n  \n\n13.区分：中介者模式和外观模式 ：\n\n1）中介者模式主要用来封装多个对象之间相互的交互，多用在系统内部；\n\n2）中介模式的实现里面，需要实现具体的交互功能，外观模式的实现组合调用或者转调内部实现的功能，外观模式并不会实现这些功能。\n\n3）中介者模式的目的主要是松散多个模块之间的耦合，把耦合关系放到中介者中去实现，外观模式目的是简化客户端的调用\n\n","tags":["外观模式"],"categories":["设计模式"]},{"title":"简单工厂模式","url":"%2Fpost%2F6b3bea20.html","content":"1\\. 接口中的方法都是抽象方法，接口中的属性都是常量（public static final）\n\n  \n\n2.接口的作用：定义实现类的外观，也就是实现类的行为定义，用于约束实现类的行为。\n\n  \n\n3.接口的思想就是“封装隔离”，通常的封装指的是对数据的封装，但这里的封装是只“对被隔离体的行为的封装”，或者说对被隔离体的 职责的封装，\n隔离指的是外部调用和内部实现，外部调用只能通过接口调用，内部实现 是被接口分开的\n\n  \n\n4.使用接口的好处，由于外部调用通过内部接口进行调用的，只要接口不变，内部实现的变化就不会影响到外部应用，从而使得更灵活，接口是系统可插拔性的保证\n\n  \n\n5.接口和抽象类的选择， 优先选择接口，如果既要定义子类的行为又要为子类提供公共的功能时应选择抽象类\n\n  \n\n6.面对接口编程是java 的一个重要原则\n\n  \n\n7.java 一般分为三个层次 表现层、逻辑层、和数据层，之间通过接口来通信，“接口是被其隔离部分的外观”\n\n  \n\n8.组件：从设计上讲就是完成一定功能的封装体\n\n  \n\n9.简单工厂的定义：提供一个创建对象实例的功能，二无需关心其具体实现，被创建的类型可以是接口、抽象类，也可以是具体的类----\n简单工厂能帮助我们真正的开始面向接口编程\n\n  \n\n10.简单工厂的功能： 可以用来创建接口，也可以创建抽象类或普通类的实例\n\n  \n\n11.静态工厂：使用简单工厂的时候，通常不用创建简单工厂类的实例，没有创建实例的必要，因此可以吧简单工厂类实现为一个工具类，直接使用静态方法就可以了。，简单工厂的方法通常是静态的，也成为静态工厂。防止客户端无谓的创建实例还可以把构造方法私有化\n\n  \n\n12.万能工厂： 工厂类中可以有多个创建实例方法的方法。\n\n  \n\n13.简单工厂方法的内部主要实现的功能是“选择合适的实现类”来创建实例对象，需要选择的条件或者参数：\n\n1）来源于客户端，由客户端传入参数 （需要暴露参数，用户可能会知道部分细节）\n\n2）来源于配置文件获取用于判断的值 （灵活，不要一直修改工厂类）\n\n3）来源于程序运行期的某个值。\n\n  \n\n14.简单工厂优点：实现了组件的封装，让组件外部能真正面向接口编程；解耦，通过简单工厂实现了客户端和具体实现类的解耦\n\n  \n\n15.简单工厂缺点：增加客户端的复杂度，如果通过参数去选择具体的实现类，那么就必须让客户端理解参数的含义和具体功能，也部分暴露了内部实现，这种情况下可以选用可配置的方式来实现。；\n不方便拓展子类。\n\n  \n\n16.简单工厂的本质：选择实现（和封装隔离（外部可以直接使用接口，不需要知道实现类））\n\n  \n\n17.如何选择简单工厂：\n\n1） 如果需要完全封装隔离具体实现，让外部只能通过接口来操作封装体，那么可以选用简单工厂，让客户端通过工厂来获取相应的接口，无需关注具体的实现。\n\n2）如果想要把对外创建对象的职责集中管理和控制，可以选用简单工厂，一个简单工厂可以创建很多的不相关的对象，将对象的创建职责集中到一个简单工厂，实现集中管理和控制\n\n","tags":["设计模式"],"categories":["设计模式"]},{"title":"AndroidEventBus教程","url":"%2Fpost%2F39808cf6.html","content":"> 每一次探索都源于好奇\n\n####**一、说明**：\n本系列主要是讲一些开源框架的使用，帮助程序员更好更快的使用开源框架，以下内容出于本人对框架的理解，如果有不对或者不准确的地方请评论，谢谢。\n我比较喜欢带着问题去研究东西，所以我列出以下几个问题，希望你们一样可以带着疑问去看，问题如下：\n\n####**二、问题：**\n 1. AndroidEventBus是什么？\n 2. 它和EventBus以及OTTO有什么关系，又有什么区别？\n 3. 它修复集合传递的问题了吗？\n 4.  粘性事件是指的什么？如何使用？\n####**三、细节：**\n下面我们来依次讲解以下，首先来说什么是AndroidEventBus：\n#### **1.AndroidEventBus 的定义**\n这个是它自身的定位：这是一个Android平台的事件总线框架, 它简化了Activity、Fragment、Service等组件之间的交互，很大程度上降低了它们之间的耦合，使得我们的代码更加简洁，耦合性更低，提升我们的代码质量。\n确实，通过我的使用感觉确实比官方的传递方式好用且方便了很多。\n\n#### **2.AndroidEventBus和EventBus以及OTTO之间的区别**\n我们先看一下下面的这个表格\n\n| 名称 | 订阅函数是否可执行在其他线程 |   特点 |\n| ------------- |-------------| -----|\n| greenrobot的EventBus | 是 | 使用name pattern模式，效率高，但使用不方便。 |\n| square的otto |   否 | 使用注解，使用方便，但效率比不了EventBus。 |\n| AndroidEventBus | 是| 使用注解，使用方便，但效率比不上EventBus。订阅函数支持tag(类似广播接收器的Action)使得事件的投递更加准确，能适应更多使用场景。 |\n\n ---\n\n - 这个比对的是Eventbus 2.x 系列的，EventBus 3.0 的已经使用注解了，而且还可以新增了粘性事件，事件优先级，根据优先级拦截消息等功能，但是仍旧不支持tag，或者分组操作，这个对我来说是痛点，所以暂时不使用EventBus3.0\n \n - 我们可以看到EventBus2.x 的时候使用的固定的方法名称（onEvent开头的方法，不太了解的自行百度，或者等我出这方面的文章），速度较快，且可以切换线程。\n - OTTO 和AndroidEventBus 都是使用注解，这样就避免了使用固定的方法名称，但OTTO不能切换线程，AndroidEventBus 拥有OTTO 的优点而且还可以通过设置tag进行分组，解决了在同一个类下面，相同的接收参数也可以正常接收的问题，不必要去封装多余的类。不过它俩都是用的是注解效率就稍微差一点。我测试的AndroidEventBus 的速度还是可以接受的。\n \n - 共同点是他们都需要通过匹配类型传递，就是你post的对象和你接受的方法的参数需要一致。\n#### **3.AndroidEventBus并没修复集合传递的问题**\n - 首先我们先描述以下问题，具体情形是这样的，假设你现在要发送的是个`List<String> stringList` 对象，且接收方法有多个，其中一个的参数是`List<Long> test` 而另一个的是`List<String> test`，这个时候我们希望的是第二个能接收到，而第一个不能接收到，但事实上两个都可以接收到。\n \n - 所以我们传递类似的集合（List、Map）的对象的时候可以通过获取其中的一个对象通过`instanceOf`判断类型，也可以将其封装成对应命名的xxEvent，将其作为参数传递。\n\n#### **4.粘性事件**\n\n - 首先我们说一下什么是粘性事件，粘性事件指事件消费者在事件发布之后才注册的也能接收到该事件的特殊类型。Android中就有这样的实例，也就是粘性广播。正常情况下如果发送者发送了某个广播，而接收者在这个广播发送后才注册自己的Receiver，这时接收者便无法接收到刚才的广播，为此Android引入了粘性广播，在广播发送结束后会保存刚刚发送的广播（Intent），这样当接收者注册完Receiver后就可以接收到刚才已经发布的广播。这就使得我们可以预先处理一些事件，让有消费者时再把这些事件投递给消费者。\n\n - 这种情形非常多见，比如我们在跳转activity时，且要传递给下一个activity数据，这个时候我们大多数都是采用序列化的方式，将其存储到Intent 中然后传递，然后下一个activity接收后再解析数据。这种情况下，为了实现序列化就需要写一大堆的模式代码。而仅仅是为了传递一个变量。当然也有其他的办法，比如存储到内存中，但这种方法维护复杂，需要及时清除。\n\n - 粘性事件将解决我们的痛点，我们可以在当前Activity 中发送粘性事件，然后当下一个Activity注册后就可以接收到此事件，所以可以通过它来传递。\n\n - 需要注意的几点如下：\n\n\n 1. 当上一个activity发送一般事件和粘性事件的时候，下一个activity即使两种都进行了注册，很明显只有粘性事件可以接收到消息（因为有消息后才注册）。\n   \n   \n 2. 当跳转到下一个activity的时候，这时候假设上一个activity已经注册了一般事件和粘性事件，此时下一个activity进行发送一般事件和粘性事件的时候上一个activity（因为注册后才有的消息）只有一般事件才能接收到，这样也就确定了传递方向和具体的使用方法。\n   \n - 需要注意的是粘性事件需要移除操作否则会一直存在。\n\n#### **5.代码怎么写？**\n\n - 首先对于一般的事件发送方的操作如下：\n `  EventBus.getDefault().post(Object)`  ,这个是不使用tag 的发送代码。\n  ` EventBus.getDefault().post(Object, tag)`, 这个是使用tag的发送代码\n这个地方可以这么理解第一种使用的是默认tag，第二种是你自定的tag，只有***参数和tag*** 能对应，对应的接收方法才能接收到\n\n - 对于一般消息的接收方做如下操作：\n``` EventBus.getDefault().register(this)``` 首先在onCreate 方法中使用这个方法进行注册。\n```EventBus.getDefault().unregister(this)``` 然后在onDestroy方法中使用这个方法反注册。\n\n  接收方的接收方法有如下几种类型：  \n```\n // 接收方法,默认的tag,执行在UI线程\n    @Subscriber\n    private void updateUser(User user) {\n        Log.e(\"\", \"### update user name = \" + user.name);\n    }\n    \n    // 含有my_tag,当用户post事件时,只有指定了\"my_tag\"的事件才会触发该函数,执行在UI线程\n    @Subscriber(tag = \"my_tag\")\n    private void updateUserWithTag(User user) {\n        Log.e(\"\", \"### update user with my_tag, name = \" + user.name);\n    }\n\n    // 含有my_tag,当用户post事件时,只有指定了\"my_tag\"的事件才会触发该函数,\n    // post函数在哪个线程执行,该函数就执行在哪个线程    \n    @Subscriber(tag = \"my_tag\", mode=ThreadMode.POST)\n    private void updateUserWithMode(User user) {\n        Log.e(\"\", \"### update user with my_tag, name = \" + user.name);\n    }\n\n    // 含有my_tag,当用户post事件时,只有指定了\"my_tag\"的事件才会触发该函数,执行在一个独立的线程\n    @Subscriber(tag = \"my_tag\", mode = ThreadMode.ASYNC)\n    private void updateUserAsync(User user) {\n        Log.e(\"\", \"### update user async , name = \" + user.name + \", thread name = \" + \n    }\n```\n\n - 对于粘性事件发送方的操作如下：\n \n``` EventBus.getDefault().postSticky(Object, tag)```\n``` EventBus.getDefault().postSticky(Object)```\n\n理解方式同一般事件。\n\n - 对于接收方的操作如下：\n\n```EventBus.getDefault().registerSticky(this)``` 首先在onCreate中使用此代码注册\n\n  它对于事件的接收同一般事件是一样的，不再赘述。\n  \n  另一个和一般事件不同，它不需要反注册，但是它需要销毁粘性事件，否则粘性事件会一直存在。\n  销毁代码如下：\n \n\n```\nEventBus.getDefault().removeStickyEvent(String.class, \"registerSticky\"); //前面是class,后面是对应的tag。销毁对应类型(Class)的，对应tag的粘性事件。\n```\n\n```\nEventBus.getDefault().removeStickyEvent(String.class); //销毁对应类型的，默认tag的粘性事件\n```\n\n需要注意销毁的时机，可以是接收后，也可以是onStop或者onDestroy，根据自身需求定。\n\n经测试粘性事件的接收函数在主线程中的，可以用于更新UI，也就是说，事件传递是在UI加载完成后的。\n\n------\n####自此分析完毕，如果想了解更多其他的框架或者文中提到的框架，请观看本博客的其他内容，后续会加入链接。\n\n","tags":["教程"],"categories":["Android"]},{"title":"拆解PinnedHeaderListView源码","url":"%2Fpost%2Fc411cb4b.html","content":"####本系列博客主要用于学习开源源码中一些优秀的编码思想技巧和一些不常见的开发方式。\n\n> 千里之行，始于足下\n\n####明确学习意图\n首先明确学习研究PinnedHeaderListView这个源码的用途，通过阅读本博客你可以了解到以下几个方面：(约定如下：官方的是HeaderView，自己定义的header叫pinnedHeaderView)\n\n 1. 如何去监听ListView，如何知道当前可见的item的位置，以及对其拓展的操作。\n 2. 了解到ListView中的HeadView 和FooterView。\n 3. 了解ViewGroup的绘制过程。\n 4. 了解View的定位方法。\n 5. 了解View的另类绘制方法。\n 6. 了解PinnedHeaderListView的核心实现原理。\n 带着上面几方面的疑惑去看下面的源码分析或许能收获更多\n\n\n\n####首先通过对代码的解读，发现其比较重要的4个类\n\n - PinnedHeaderListView: 实现组的头部总是悬浮在顶部的listview \n - SectionedBaseAdapter: 封装的adapter的抽象类 \n - PinnedHeaderListViewMainActivity: 具体使用的activity \n - TestSectionedAdapter: 实现了抽象类SectionedBaseAdapter的adapter\n\n####我们先来解读以下SectionedBaseAdapter\n我们看到它实现了PinnedHeaderListView.PinnedSectionedHeaderAdapter  这个接口\n其定义如下：\n\n```\n public static interface PinnedSectionedHeaderAdapter {\n     public boolean isSectionHeader(int position); //是否是组的头部\n     public int getSectionForPosition(int position); //根据位置判断对应的组号\n     public View getSectionHeaderView(int section, View convertView, ViewGroup parent); // 得到组的头部view\n      public int getSectionHeaderViewType(int section); \n      public int getCount();\n    }\n```\n比较重要的方法后面都有了对应的注释，源码中写的也比较简单，在次不再细说，主要是getSectionHeaderView方法比较重要，是我们获取headView的方法。此处不是我们研究的重点，感兴趣的可以去深入研究一下。\n####下面我们来分析一下PinnedHeaderListView\n我们看到它\n\n```\npublic class PinnedHeaderListView extends ListView implements OnScrollListener , AdapterView.OnItemClickListener\n```\n主要是OnScrollListener  这个是我们监听当前的Listview滚动状态的监听器。\n我们先总体的看一下OnScroll里面的方法，代码如下：\n\n```\n@Override\n    public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {\n        if (mOnScrollListener != null) {\n            mOnScrollListener.onScroll(view, firstVisibleItem, visibleItemCount, totalItemCount);//使外部也可以监听到onScroll事件\n        }\n        headerCount = getHeaderViewsCount();//获取headView\n        if (mAdapter == null || mAdapter.getCount() == 0 || !mShouldPin || (firstVisibleItem < headerCount)) {\n            mCurrentHeader = null;\n            mHeaderOffset = 0.0f;\n            for (int i = firstVisibleItem; i < firstVisibleItem + visibleItemCount; i++) {\n                View header = getChildAt(i);\n                if (header != null) {\n                    header.setVisibility(VISIBLE);\n                }\n            }\n            return;\n        }\n\n        firstVisibleItem -= getHeaderViewsCount();//去掉header view的影响\n\n        int section = mAdapter.getSectionForPosition(firstVisibleItem); //得到组号\n        int viewType = mAdapter.getSectionHeaderViewType(section);\n        mCurrentHeader = getSectionHeaderView(section, mCurrentHeaderViewType != viewType ? null : mCurrentHeader);\n        //layout header,使它在最顶端\n        ensurePinnedHeaderLayout(mCurrentHeader);\n        mCurrentHeaderViewType = viewType;\n        mHeaderOffset = 0.0f;\n        for (int i = firstVisibleItem; i < firstVisibleItem + visibleItemCount; i++) {\n            if (mAdapter.isSectionHeader(i)) {\n                View header = getChildAt(i - firstVisibleItem);\n                float headerTop = header.getTop();\n                float pinnedHeaderHeight = mCurrentHeader.getMeasuredHeight();\n                header.setVisibility(VISIBLE);\n                if (pinnedHeaderHeight >= headerTop && headerTop > 0) { // 下一个组的头部快滑动到顶部，距离顶部的距离小于现在在顶部悬浮的head的高度了\n                    mHeaderOffset = headerTop - header.getHeight(); //MheaderOffset是小于0的\n                } else if (headerTop <= 0) { //下一个组的头部滑动到了顶部了\n                    header.setVisibility(INVISIBLE);\n                }\n            }\n        }\n        invalidate();\n    }\n```\n此处的代码比较多，我们一点一点的进行分析。\n#### 代码细节\n - **设置外部监听的回调**：\n```\nif (mOnScrollListener != null) {\n            mOnScrollListener.onScroll(view, firstVisibleItem, visibleItemCount, totalItemCount);//使外部也可以监听到onScroll事件\n        }\n```\n这段代码是让用户设置滑动监听的时候也能监听到对应的事件\n \n - **获取Listview的HeaderView**\n```\n headerCount = getHeaderViewsCount(); //获取headView\n```\n首先我们得了解一下什么是headerView，怎么使用。\nheadview是通过listview.addHeaderView（）的方式添加的，此处可以添加的任何一种类型的view,而且此处的布局是不需要经过adpter也就是说不需要经过getView（）。\n如果当你需要在Listview最上方设置一个布局且不需要它随着下面的数据的变动而改变使用此方法正合适。另一个与之对应的是addFooterView（）,这个就是加底部的布局的。\n\n此方法是用于获取headerView的数量的，从而我们也就知道了，headerView是可以设置多个的。（headerview会影响onItemClickLisener方法中的position）\n\n - **判断的符合条件**\n```\nif (mAdapter == null || mAdapter.getCount() == 0 || !mShouldPin || (firstVisibleItem < headerCount)) {\n                 ...\n                 return\n}\n```\n如果满足了这些条件的话就直接return ，这些属于无效条件\n \n - **得到分组相关的数据**\n\n```\n   firstVisibleItem -= getHeaderViewsCount();//去掉header view的影响\n   int section = mAdapter.getSectionForPosition(firstVisibleItem); //得到组号\n   int viewType = mAdapter.getSectionHeaderViewType(section);\n   mCurrentHeader = getSectionHeaderView(section, mCurrentHeaderViewType != viewType ? null : mCurrentHeader);\n```\n\n之前我们说过headerView会影响我们的position，影响的内容为getView中使用的postion和OnItemClickLisener中的postion不对应，所以我们需要消除headerView的影响，减去headerView的数量，就是其在getView中的位置\n\n - **重置数据并使headerView一直在最上方**\n\n```\n   ensurePinnedHeaderLayout(mCurrentHeader);//重新对mCurrentHeader定位，让其一直在最上方\n   mCurrentHeaderViewType = viewType;\n   mHeaderOffset = 0.0f;//移动的间距\n```\n比较重要的方法就是ensurePinnedHeaderLayout（）我们稍后详细的分析它。\n\n - **正真的核心代码**\n \n\n```\n    for (int i = firstVisibleItem; i < firstVisibleItem + visibleItemCount; i++) {\n            if (mAdapter.isSectionHeader(i)) {\n                View header = getChildAt(i - firstVisibleItem);\n                float headerTop = header.getTop();\n                float pinnedHeaderHeight = mCurrentHeader.getMeasuredHeight();\n                header.setVisibility(VISIBLE);\n                if (pinnedHeaderHeight >= headerTop && headerTop > 0) { // 下一个组的头部快滑动到顶部，距离顶部的距离小于现在在顶部悬浮的head的高度了\n                    mHeaderOffset = headerTop - header.getHeight(); //MheaderOffset是小于0的\n                } else if (headerTop <= 0) { //下一个组的头部滑动到了顶部了\n                    header.setVisibility(INVISIBLE);\n                }\n            }\n        }\n```\n\n从整体上看，这是遍历可视范围内的item，然后通过`mAdapter.isSectionHeader(i)`判断是不是header,然后通过`getChildAt(i - firstVisibleItem)` 获取当前listview对应位置的布局，通过这两个判断同时成立的话就是获取当前最上方的pinnedHeaderView 。而mCurrentHeader 是上一个组的pinnedHeaderView ，通过`header.getTop()` 获取当前最上方的pinnedHeaderView 距离上方的位置，通过`mCurrentHeader.getMeasuredHeight()` 获取上一个pinnedHeaderView 的高度，通过`header.setVisibility(VISIBLE)`  恢复header的显示，这个是用于往回滚时的操作，与之对应的是`header.setVisibility(INVISIBLE)`\n我们先看一下这个判断条件`if (pinnedHeaderHeight >= headerTop && headerTop > 0)`，当当前的mCurrentHeader高度大于当前最上方的pinnedHeaderView 的话说明此时下方已经和当前的mCurrentHeader将要交叉。通过` mHeaderOffset = headerTop - header.getHeight()` 获取偏移量\n另一个判断`(headerTop <= 0)` 这个是当当前的header划过顶部的时候，通过` header.setVisibility(INVISIBLE);`进行隐藏，所以我们也就知道了它正真的过程，是当划过的时候将其隐藏了，回来的时候又重新设置可见了，而上方的View又是怎么回事呢？我们来继续分析\n\n####未完待续...\n ","tags":["HeaderView"],"categories":["源来如此"]},{"title":"Android技巧总结  系列一","url":"%2Fpost%2F276dec51.html","content":"####  本系列博客就是用于总结平时开发用到的技巧或者方法，用于开发者能更好的编码，如果有帮助或者有错误都可以下方留言，谢谢\n\n> 成功源于开始的积累\n\n  1. String.format（“3>7是：%b”,3>7） 输出是3>7是false   \n作用：用于替换输出，只需要更改输入的内容，结果和根据输入的内容去更改\n\n  2. ` String result = \"实时更新中，当前大盘指数<font color='red'>%d</font>\" Html.fromHtml(result) ` ; 可以将文字像html一样编写, 返回格式spanner类型，可以通过textview的settext进行设置。作用：显示一句话时，不同的文字不同的颜色。 \n  3. ViewStub是一种默认不可见的视图，它没有大小所以不能被改变，它可以设置layout属性，当我们想加载对应的布局的时候调用inflate加载，在未使用的时候消耗较低的内存。作用：优化ui加载性能，替代设置View.GONE ，不过这个只能加载一次，如果多次的情况仍然推荐使用设置View的View.GONE \n  4. View 停止动画的方法：clearAnimation（）。 \n  5. 一般情况下我们无法在OnCreate()中获取View的宽高，不过通过以下代码强制测量就可以得到了   \n我们在onCreate里面得到的控件的宽高全是０。采用下面的方法，可以得到真实的宽高 \n```  \nint w = View.MeasureSpec.makeMeasureSpec(0,View.MeasureSpec.UNSPECIFIED);  \nint h = View.MeasureSpec.makeMeasureSpec(0,View.MeasureSpec.UNSPECIFIED);  \nimageView.measure(w, h);  \nint height =imageView.getMeasuredHeight();  \nint width =imageView.getMeasuredWidth();  \ntextView.append(\"\\n\"+height+\",\"+width);  \n```\n\n  6. 对与ListView有的时候不设置宽度会导致无法点击Item \n  7. 对于类的静态成员变量，它对于类本身和类所有的对象都是公用的，它使用的是同一块内存空间，更改其中的一个其他的也会修改。 \n  8. 一个接口可以继承多个接口.interface C extends A, B {}是可以的.   \n一个类可以实现多个接口:class D implements A,B,C{}  \n但是一个类只能继承一个类,不能继承多个类 class B extends A{}  \n在继承类的同时,也可以继承接口:class E extends D implements A,B,C{}  \n这也正是选择用接口而不是抽象类的原因\n\n  9. RelativeLayout 设置垂直居中此时设置marggin_top 或者marggin_bottom 仍然有效 \n  10. EditText有一个属性：android:textCursorDrawable，这个属性是用来控制光标颜色的   \nandroid:textCursorDrawable=”@null”，”@null”作用是让光标颜色和text color一样，当然也可以设置为其他颜色\n\n  11. 如果想让软键盘不自动弹出 设置activity 属性 android:windowSoftInputMode=”adjustUnspecified|stateHidden”   \nstateUnspecified ：未指定默认状态 stateHidden：隐藏 ，默认隐藏，点击后会显示  \nadjustUnspecified： 让界面适应软键盘的位置和大小会让界面上移\n\n  12. 第二种不让软键盘弹出的方法就是设置他的父布局focusable=”true” ，软键盘一样可以不弹出。 \n  13. 判断一个类是不是另一的实例（对于接口也适用）activity instanceof ISearch \n  14. 如果设置的布局用于Fragenment或者popuwindow，此时的点击时间传递到了下面的布局时，可以设置Fragement或者popuwindow的布局 ` android:clickable=\"true\" ` 。 \n  15. List 对对应位置的操作有 add(int postion， object object) 这个是在指定位置添加，且他后面的的向后退。set（position， object object ） 设置某个位置的对象为谁，之前的被替换。 \n  16. popuwindow 不支持内部再添加surfaceView \n  17. include 方式导入通用布局使用layout_width 和layout_height 会覆盖原布局的此属性 \n  18. 对于对象的初始化设置为null ，会节省内存。 \n  19. 属性动画可以设置多个动画同时进行。传统动画只能设置一个view 的多个动画 \n  20. Button可以通过设置Selector切换不同状态的背景图，TextView也可以通过selector去切换不同状态的文字颜色，此时TextView 需要设置clickable=true \n\n","tags":["进阶"],"categories":["android技巧"]},{"title":"android 自定义view起步之一","url":"%2Fpost%2F4288d0c6.html","content":" [toc]\n\n本文中用到的例子是来自于http://blog.csdn.net/lmj623565791/article/details/24300125，只是为了方便更多的人了解自定义view的过程对其中的代码进行详细的解释，如果给原作者带来的不便还请谅解，如果本文中，有什么说的不对的地方，还请指正，谢谢。\n对于自定义view来说我们通常走的步骤大概分为：\n> 1、自定义View的属性\n2、在View的构造方法中获得我们自定义的属性\n[ 3、重写onMesure ]\n4、重写onDraw     \n\n我们以上面提到的例子源码进行详细的分析：\n\n**一、代码解析**\n----------\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n    <!-- 自定义属性 -->\n    <attr name=\"titleText\" format=\"string\" />\n    <!-- 前面是自定义属性的名称，后面是可使用的类型,注意大小写 -->\n    <attr name=\"titleSize\" format=\"dimension\" />\n    <!-- 这个表示只要是颜色都可以 -->\n    <attr name=\"titleColor\" format=\"color\" />\n    <!-- 这个表示只要是资源文件即可 -->\n    <attr name=\"image\" format=\"reference\" />\n    <!-- 这种类似于填写相对位置信息时的选项下面的枚举类型就是可选项 -->\n    <attr name=\"imageScaleType\">\n        <enum name=\"fillXY\" value=\"0\" />\n        <enum name=\"center\" value=\"1\" />\n    </attr>\n\n    <!-- 此处用于说明CustomImageView 有哪些属性 -->\n    <declare-styleable name=\"customImageView\">\n        <attr name=\"titleText\" />\n        <attr name=\"titleSize\" />\n        <attr name=\"titleColor\" />\n        <attr name=\"image\" />\n        <attr name=\"imageScaleType\" />\n    </declare-styleable>\n\n</resources>\n```\n这个是属性文件的内容，在 res/valuse/attr.xml  设置此属性，代码中已经做出了详细的解释，在此先不赘诉。\n\n下面的是整个view的编写代码，也有了详细的注释，稍后对其中的代码片段进行解释。\n\n```\npublic class customImageView extends View {\n    private Bitmap mImage;\n    private int mImageScale;\n    private String mTitle;\n    private int mTextColor;\n    private int mTextSize;\n    private Rect rect;\n    private Paint mPaint;\n    private Rect mTextBound;\n    private int mWidth;\n    private int mHeight;\n    private static int IMAGE_SCALE_FITXY = 0;\n\n    public customImageView(Context context, AttributeSet attrs) {\n        this(context, attrs, 0);// 此处一定要写成this\n                                // ，因为你除非设置样式否则都会执行第一或者第二个构造函数，不会经过第三个，所以第一第二个要调用第三个\n        // TODO Auto-generated constructor stub\n    }\n\n    public customImageView(Context context) {\n        this(context, null);\n        // TODO Auto-generated constructor stub\n    }\n\n    public customImageView(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        // 获取我们自定义的属性\n        // 得到属性数组 //attrs 属性集合（哪一个对应那些值） 属性集（前面的那个的哪一个） 默认样式\n        TypedArray array = context.getTheme().obtainStyledAttributes(attrs,\n                R.styleable.customImageView, defStyleAttr, 0);// 这个地方传入的R.styleable.customImageView\n                                                                // 就是需要筛选的集合\n        int n = array.getIndexCount();\n        for (int i = 0; i < n; i++) {\n            int attr = array.getIndex(i); // 获取其中的一个属性\n            switch (attr) {\n            case R.styleable.customImageView_image:\n                // array 通过get 方法，通过传入的标识(attr)，获取对应的属性的内容，此处的就是图片资源\n                mImage = BitmapFactory.decodeResource(getResources(),\n                        array.getResourceId(attr, 0));\n                // bitmap工厂类生成bitmap\n\n                break;\n            case R.styleable.customImageView_imageScaleType:\n                mImageScale = array.getInt(attr, 0);// 此处是整数 //放大倍数\n                break;\n            case R.styleable.customImageView_titleText:\n                mTitle = array.getString(attr);\n                break;\n            case R.styleable.customImageView_titleColor:\n                mTextColor = array.getColor(attr, 0);\n                break;\n            case R.styleable.customImageView_titleSize:\n                mTextSize = array.getDimensionPixelSize(attr, (int) TypedValue\n                        .applyDimension(TypedValue.COMPLEX_UNIT_SP, 16,\n                                getResources().getDisplayMetrics()));\n                break;\n            default:\n                break;\n            }\n        }\n        array.recycle(); // 释放内存资源\n        rect = new Rect(); // 矩形画布\n        mPaint = new Paint();// 新建画笔\n        mTextBound = new Rect();// 文字的矩形画布\n        // 画笔根据文字内容测算文字矩形画布的宽高并赋值给mTextBound（此时是包裹文字的最小矩形）\n        mPaint.getTextBounds(mTitle, 0, mTitle.length(), mTextBound);\n\n    }\n\n    // 测量函数\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {// 此处传入的值由父容器决定\n        // ---设置控件宽度---\n        int specMode = MeasureSpec.getMode(widthMeasureSpec); // 获取宽度的设置类型\n        int specSize = MeasureSpec.getSize(widthMeasureSpec);// 获取宽度大小\n\n        if (specMode == MeasureSpec.EXACTLY) {// fill_parent,或者具体值 --type ： 精确模式\n            mWidth = specSize;\n        } else {//非精确模式\n            // 由图片决定的宽\n            int desireByImg = getPaddingLeft() + getPaddingRight()\n                    + mImage.getWidth();\n            // 由文字决定的宽\n            int desireByTitle = getPaddingLeft() + getPaddingRight()\n                    + mTextBound.width();\n            if (specMode == MeasureSpec.AT_MOST) {// wrap_content\n                int desire = Math.max(desireByImg, desireByTitle); // 获取文字和图片之间的最大值，保证能正常显示\n                mWidth = Math.min(specSize, desire); // 此处的specSize 是父布局剩余的大小\n                                                        // 选择能正常显示和剩余大小的最小值//也就是说如果剩余值大于最小值此时图片会显示不完整，下面的代码会详细标明\n            }\n\n        }\n        // ---设置高度---\n        specMode = MeasureSpec.getMode(heightMeasureSpec);\n        specSize = MeasureSpec.getSize(heightMeasureSpec);\n\n        if (specMode == MeasureSpec.EXACTLY) {\n            mHeight = specSize;\n        } else {\n            int desire = getPaddingTop() + getPaddingBottom()\n                    + mImage.getHeight() + mTextBound.height();\n            if (specMode == MeasureSpec.AT_MOST) { // 同上理解\n                mHeight = Math.min(desire, specSize);\n            }\n        }\n        setMeasuredDimension(mWidth, mHeight);// 设置当前控件的宽高\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        // ---------绘制一个宽度为4的矩形边框----------------\n        mPaint.setStrokeWidth(4);// 设置画笔宽度\n        mPaint.setStyle(Paint.Style.STROKE); // 设置画笔填充样式\n        mPaint.setColor(Color.CYAN);// 设置画笔颜色\n        // 绘制一个矩形，左上坐标为0,0 右下为getMeasuredWidth(), getMeasuredHeight()\n        canvas.drawRect(0, 0, getMeasuredWidth(), getMeasuredHeight(), mPaint);\n        // --------设置这个控件的4个位置信息--------------------------------------------\n        rect.left = getPaddingLeft(); // 左上的x 坐标\n        rect.right = mWidth - getPaddingRight();// 右下的x 坐标 ，看mWidth 的组成\n                                                // 减去这个getPaddingRight等同于getPaddingLeft()+控件自身所用到的宽度\n        rect.top = getPaddingTop();// 左上的y\n        rect.bottom = mHeight - getPaddingBottom(); // 右下的y ，解释同上\n\n        // ---------开始绘制文字----------------------\n        mPaint.setColor(mTextColor);\n        mPaint.setStyle(Style.FILL);\n        // 当设置的宽度小于字体需要的宽度，将内容更改为xxx... 后面为省略号的形式\n        if (mTextBound.width() > mWidth) {\n            TextPaint paint = new TextPaint(mPaint);\n            String msg = TextUtils.ellipsize(mTitle,\n                    paint, // 参数含义 原始内容，画笔，真实宽度，出现“...”的方式（中间或者结尾）\n                    (float) mWidth - getPaddingLeft() - getPaddingRight(),\n                    TextUtils.TruncateAt.END).toString();\n            canvas.drawText(msg, getPaddingLeft(),\n                    mHeight - getPaddingBottom(), mPaint); // 特别指出\n\n        } else {\n            // 正常情况，将字体居中\n            canvas.drawText(mTitle, mWidth / 2 - mTextBound.width() * 1.0f / 2,\n                    mHeight - getPaddingBottom(), mPaint);\n        }\n\n        // 去掉使用掉的高度\n        rect.bottom -= mTextBound.height();\n\n        if (mImageScale == IMAGE_SCALE_FITXY) {\n            canvas.drawBitmap(mImage, null, rect, mPaint);\n        } else {\n            rect.left = mWidth / 2 - mImage.getWidth() / 2; // 图片大于控件宽度的时候会是负值，图片会被裁剪、、也就是说会有一部分显示不出来\n            rect.right = mWidth / 2 + mImage.getWidth() / 2;\n            rect.top = (mHeight - mTextBound.height()) / 2 - mImage.getHeight()\n                    / 2;\n            rect.bottom = (mHeight - mTextBound.height()) / 2\n                    + mImage.getHeight() / 2;\n            canvas.drawBitmap(mImage, null, rect, mPaint);\n\n        }\n\n    }\n}\n```\n\n**二、疑问解答**\n----------\n\n下面对其中出现的不太容易理解的地方进行分析：\n\n **1. 下面这行代码的含义是什么呢？**  \n\n```\n    mTextSize = array.getDimensionPixelSize(attr, (int) TypedValue\n                        .applyDimension(TypedValue.COMPLEX_UNIT_SP, 16,\n                                getResources().getDisplayMetrics()));\n```\ngetDimensionPixelSize 这个方法的功能是获取像素值，TypedValue  .applyDimension(TypedValue.COMPLEX_UNIT_SP, 16,\n                                getResources().getDisplayMetrics())  这个代码的含义是将16转化为sp 格式时int 的值。也就是16sp 的int 值。\n\n **2. 这个将文字居中怎么理解？**\n \n\n```\n    // 正常情况，将字体居中\n            canvas.drawText(mTitle, mWidth / 2 - mTextBound.width() * 1.0f / 2,\n                    mHeight - getPaddingBottom(), mPaint);\n```\n首先我们要理解一下canvas.drawText(text, x, y, paint) 这个函数的含义：首先第一个和第四个参数的含义很容易理解，第一个是需要绘制的文本，最后一个是所使用的画笔，x,y 的话按照一般的规律来说应该是文本的位置信息，但是他的x,y 并不是一般的理解思路， 首先y 的确定上跟baseline 有关，不清楚的可以百度一下，这个就不解释了，x 和设置的文字的居中方式有关，如果设置了paint.setTextAlign(Paint.Align.CENTER)，则x 的起点默认是字符的中心位置，默认是最左侧。\n所以上面的y 的计算其实是计算baseline ，x的位置参考下图：\n![x的位置理解](http://img.blog.csdn.net/20160419002607799)\n\n未完待续...\n-------\n","tags":["view"],"categories":["Android"]},{"title":"对于RE文件管理器打开安卓手机的Sqlite文件速度很慢的解决办法","url":"%2Fpost%2Fc50b688a.html","content":"开发的时候遇到这类的事件了，当时需要查看手机数据库信息是否写入正确，但是使用RE的时候打开很慢，要等很久，找了许久才找到问题。一、手机没有root，此时是打不开的状态。二、手机root不完整，重新卸载之前的root工具下载其他的或者原来的新版工具重新root（我遇到的就是此类）\n\n","tags":["Android 技术笔记"],"categories":["Android"]}]